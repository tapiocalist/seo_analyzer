<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SEOé¡µé¢åˆ†æå·¥å…·</title>
    <meta name="description" content="ç®€æ´çš„SEOé¡µé¢åˆ†æå·¥å…·ï¼Œæ£€æµ‹ç½‘é¡µTitleã€Descriptionã€Hæ ‡ç­¾ã€å…³é”®è¯å¯†åº¦ç­‰">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f9f9f9;
            color: #202020;
            line-height: 1.5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .header h1 {
            font-size: 2.5em;
            font-weight: 700;
            color: #644a40;
            margin-bottom: 8px;
        }

        .header p {
            font-size: 1.1em;
            color: #646464;
        }

        .card {
            background: #fcfcfc;
            border: 1px solid #d8d8d8;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 16px;
        }

        .input-group {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
        }

        .input-group input,
        .input-group textarea {
            flex: 1;
            padding: 12px;
            border: 1px solid #d8d8d8;
            border-radius: 6px;
            font-size: 14px;
            background: #fcfcfc;
            color: #202020;
        }

        .input-group input:focus,
        .input-group textarea:focus {
            outline: none;
            border-color: #644a40;
            box-shadow: 0 0 0 2px rgba(100, 74, 64, 0.1);
        }

        .btn {
            padding: 12px 24px;
            background: #644a40;
            color: #ffffff;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .btn:hover {
            background: #66493e;
        }

        .btn:disabled {
            background: #efefef;
            color: #646464;
            cursor: not-allowed;
        }

        .loading {
            display: none;
            text-align: center;
            margin: 20px 0;
            color: #646464;
        }

        .error {
            background: #e54d2e;
            color: #ffffff;
            padding: 12px;
            border-radius: 6px;
            margin: 16px 0;
            display: none;
        }

        .section-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #644a40;
            margin-bottom: 12px;
            padding-bottom: 6px;
            border-bottom: 1px solid #d8d8d8;
        }

        .meta-grid {
            display: grid;
            gap: 16px;
        }

        .meta-item {
            background: #efefef;
            padding: 16px;
            border-radius: 6px;
        }

        .meta-label {
            font-weight: 600;
            color: #644a40;
            margin-bottom: 4px;
            font-size: 14px;
        }

        .meta-value {
            color: #202020;
            word-break: break-word;
            font-size: 14px;
        }

        .status {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 8px;
        }

        .status.good {
            background: #ffdfb5;
            color: #582d1d;
        }

        .status.warning {
            background: #ffe6c4;
            color: #582d1d;
        }

        .status.error {
            background: #e54d2e;
            color: #ffffff;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 16px;
        }

        .stat-card {
            background: #efefef;
            padding: 20px;
            border-radius: 6px;
            text-align: center;
        }

        .stat-number {
            font-size: 2em;
            font-weight: 700;
            color: #644a40;
            margin-bottom: 4px;
        }

        .stat-label {
            font-size: 12px;
            color: #646464;
            font-weight: 500;
        }

        .heading-item {
            padding: 6px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
            border-left: 2px solid #644a40;
        }

        .heading-item.h1 {
            margin-left: 0;
            font-weight: normal;
        }

        .heading-item.h2 {
            margin-left: 24px;
            font-weight: normal;
        }

        .heading-level {
            background: #644a40;
            color: #ffffff;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            min-width: 24px;
            text-align: center;
        }

        .heading-text {
            color: #202020;
            line-height: 1.4;
            font-size: 14px;
            font-weight: normal;
        }

        .keyword-categories {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 16px;
        }

        .keyword-category {
            border: 1px solid #d8d8d8;
            border-radius: 6px;
            overflow: hidden;
        }

        .keyword-category-header {
            background: #efefef;
            padding: 12px 16px;
            font-weight: 600;
            color: #644a40;
            border-bottom: 1px solid #d8d8d8;
        }

        .keyword-list {
            padding: 12px;
        }

        .keyword-item {
            padding: 6px 0;
            border-bottom: 1px solid #e8e8e8;
        }

        .keyword-item:last-child {
            border-bottom: none;
        }

        .keyword-text {
            font-weight: 500;
            color: #202020;
            margin-bottom: 4px;
        }

        .keyword-count {
            background: #ffdfb5;
            color: #582d1d;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 12px;
            display: inline-block;
        }


        .batch-textarea {
            width: 100%;
            height: 100px;
            padding: 12px;
            border: 1px solid #d8d8d8;
            border-radius: 6px;
            resize: vertical;
            font-family: monospace;
            font-size: 13px;
            margin-bottom: 12px;
        }

        .progress-section {
            background: #e8e8e8;
            border-radius: 6px;
            padding: 16px;
            margin-top: 16px;
            display: none;
        }

        .progress-bar {
            background: #d8d8d8;
            height: 6px;
            border-radius: 3px;
            overflow: hidden;
            margin: 8px 0;
        }

        .progress-fill {
            background: #644a40;
            height: 100%;
            width: 0%;
            transition: width 0.3s;
        }

        .progress-details {
            font-size: 12px;
            color: #646464;
            margin-top: 8px;
        }

        .no-data {
            text-align: center;
            color: #646464;
            padding: 40px;
            font-style: italic;
        }

        .supplement-section {
            margin-top: 16px;
        }

        .supplement-section h3 {
            color: #644a40;
            margin-bottom: 12px;
            font-size: 1.1em;
        }

        .serp-table {
            width: 100%;
            border-collapse: collapse;
            background: #fcfcfc;
            border: 1px solid #d8d8d8;
            border-radius: 6px;
            overflow: hidden;
        }

        .serp-table th {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #d8d8d8;
            color: #644a40;
            font-weight: 600;
            background: #efefef;
            font-size: 14px;
        }

        .serp-table td {
            padding: 8px;
            border-bottom: 1px solid #e8e8e8;
            vertical-align: top;
            font-size: 14px;
            line-height: 1.3;
        }

        .serp-table tr:last-child td {
            border-bottom: none;
        }

        .results {
            display: none;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px 16px;
            }

            .input-group {
                flex-direction: column;
            }

            .header h1 {
                font-size: 2em;
            }

            .card > div[style*="grid-template-columns"] {
                grid-template-columns: 1fr !important;
                gap: 12px !important;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>SEOé¡µé¢åˆ†æå·¥å…·</h1>
            <p>åˆ†æHTMLæ–‡ä»¶SEOè¦ç´ ï¼šTitleã€Descriptionã€Hæ ‡ç­¾ã€å…³é”®è¯å¯†åº¦</p>
        </div>

        <!-- æœ€è¿‘åˆ†æè®°å½• -->
        <div id="recentHistory" class="card" style="display: none; margin-bottom: 24px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                <h3 style="color: #644a40; margin: 0;">æœ€è¿‘åˆ†æè®°å½•</h3>
                <button class="btn" onclick="clearHistory()" style="background: #dc3545; font-size: 11px; padding: 4px 8px;">æ¸…ç©ºå†å²</button>
            </div>
            <div id="historyList" style="max-height: 120px; overflow-y: auto;"></div>
        </div>

        <!-- æ‰¹é‡ä¸‹è½½HTMLåŒºåŸŸ -->
        <div class="card">
            <h3 style="margin-bottom: 12px; color: #644a40;">æ‰¹é‡ä¸‹è½½HTML</h3>
            <textarea id="batchUrls" class="batch-textarea" placeholder="æ¯è¡Œä¸€ä¸ªURLï¼š&#10;https://www.example1.com&#10;https://www.example2.com" style="height: 112px; margin-bottom: 8px;"></textarea>
            <button class="btn" onclick="batchDownload()" id="batchBtn">æ‰¹é‡ä¸‹è½½</button>
        </div>

        <!-- åˆ†æHTMLæ–‡ä»¶åŒºåŸŸ -->
        <div class="card">
            <h3 style="margin-bottom: 12px; color: #644a40;">åˆ†æHTMLæ–‡ä»¶</h3>
            <input type="file" id="fileInput" accept=".html,.htm" multiple style="width: 100%; padding: 12px; border: 1px solid #d8d8d8; border-radius: 6px; font-size: 14px; background: #fcfcfc; color: #202020; margin-bottom: 8px;">
            <div style="font-size: 13px; color: #666; margin-bottom: 8px;">ğŸ’¡ æ”¯æŒå¤šæ¬¡é€‰æ‹©æ–‡ä»¶ï¼Œæ–°é€‰æ‹©çš„æ–‡ä»¶ä¼šæ·»åŠ åˆ°åˆ—è¡¨ä¸­ï¼ˆé‡å¤æ–‡ä»¶ä¼šè‡ªåŠ¨è·³è¿‡ï¼‰</div>

            <!-- æ–‡ä»¶åˆ—è¡¨æ˜¾ç¤ºåŒºåŸŸ -->
            <div id="fileList" style="margin-bottom: 12px;"></div>

            <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                <button class="btn" onclick="analyzeAllFiles()" id="analyzeAllBtn" style="display: none;">åˆ†æå…¨éƒ¨</button>
                <button class="btn" onclick="copyAllToExcel()" id="copyAllBtn" style="background: #28a745; display: none;">å¤åˆ¶å…¨éƒ¨åˆ°Excel</button>
                <button class="btn" onclick="clearCacheData()" style="background: #dc3545; font-size: 12px; padding: 8px 12px;">æ¸…é™¤ç¼“å­˜</button>
            </div>
        </div>

            <div id="batchProgress" class="progress-section">
                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                    <span id="progressText">å‡†å¤‡ä¸‹è½½...</span>
                    <span id="progressCount">0/0</span>
                </div>
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill"></div>
                </div>
                <div id="progressDetails" class="progress-details"></div>
            </div>
        </div>

        <div class="loading">
            <p>æ­£åœ¨åˆ†æ...</p>
        </div>

        <div class="error" id="errorMessage"></div>

        <div class="results" id="results">
            <!-- å¤åˆ¶åˆ°ExcelæŒ‰é’® -->
            <div style="text-align: right; margin-bottom: 16px;">
                <button class="btn" onclick="copyToExcel()" style="background: #28a745; font-size: 12px; padding: 6px 12px;">ğŸ“‹ å¤åˆ¶åˆ°Excel</button>
            </div>

            <!-- é¡µé¢ä¿¡æ¯å’Œæ ‡é¢˜ç»“æ„å¹¶åˆ— -->
            <div class="card">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px;">
                    <div>
                        <div class="meta-grid" id="basicInfo"></div>

                        <!-- å…³é”®è¯æŒ‡æ ‡åŒºåŸŸ -->
                        <div id="keywordMetrics" style="margin-top: 20px;"></div>
                    </div>
                    <div>
                        <!-- é¡µé¢åŸºæœ¬ä¿¡æ¯æ”¾åœ¨æ ‡é¢˜ç»“æ„ä¸Šé¢ -->
                        <div id="titleDescriptionInfo" style="margin-bottom: 20px;"></div>

                        <div id="headingsInfo"></div>
                    </div>
                </div>
            </div>

            <div class="card">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                    <h2 class="section-title" style="margin-bottom: 0;">å…³é”®è¯å¯†åº¦</h2>
                    <div style="color: #646464; font-size: 14px;">å•è¯æ•°ï¼š<span style="font-weight: 600; color: #644a40;" id="wordCountDisplay">0</span></div>
                </div>
                <div class="keyword-categories" id="keywordsInfo"></div>
            </div>

            <div id="supplementCard" class="card" style="display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                    <h2 class="section-title" style="margin-bottom: 0;">SERPç«äº‰åˆ†æ</h2>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn" onclick="copyAllUrls()" style="background: #666; font-size: 12px; padding: 6px 12px;">å¤åˆ¶æ‰€æœ‰ç½‘å€</button>
                        <button class="btn" onclick="batchDownloadSerpUrls()" style="background: #644a40; font-size: 12px; padding: 6px 12px;">æ‰¹é‡ä¸‹è½½HTML</button>
                    </div>
                </div>
                <div id="supplementInfo"></div>

                <!-- SERPä¸‹è½½è¿›åº¦æ˜¾ç¤º -->
                <div id="serpProgress" class="progress-section" style="display: none; margin-top: 16px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                        <span id="serpProgressText">å‡†å¤‡ä¸‹è½½...</span>
                        <span id="serpProgressCount">0/0</span>
                    </div>
                    <div class="progress-bar">
                        <div id="serpProgressFill" class="progress-fill"></div>
                    </div>
                    <div id="serpProgressDetails" class="progress-details"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        async function analyzeFile() {
            const fileInput = document.getElementById('fileInput');

            if (!fileInput.files || fileInput.files.length === 0) {
                showError('è¯·é€‰æ‹©HTMLæ–‡ä»¶');
                return;
            }

            const file = fileInput.files[0];

            if (!file.name.toLowerCase().endsWith('.html') && !file.name.toLowerCase().endsWith('.htm')) {
                showError('è¯·é€‰æ‹©HTMLæ–‡ä»¶');
                return;
            }

            showLoading(true);

            try {
                const html = await file.text();
                const analysis = analyzePage(html, file.name);

                // æ£€æŸ¥æ˜¯å¦æœ‰è¡¥å……ä¿¡æ¯
                const supplementData = document.getElementById('supplementDataInput').value.trim();
                let supplementInfo = null;
                if (supplementData) {
                    try {
                        supplementInfo = parseKeywordAndSerpData(supplementData);
                    } catch (error) {
                        console.warn('è¡¥å……ä¿¡æ¯è§£æå¤±è´¥', error);
                    }
                }

                // ä¿å­˜æ–‡ä»¶æ•°æ®åˆ°localStorage
                console.log('å‡†å¤‡ä¿å­˜æ–‡ä»¶æ•°æ®:', file.name);
                saveFileData(file.name, html, {
                    analysis: analysis,
                    supplementInfo: supplementInfo
                });

                // ä¿å­˜åˆ°å†å²è®°å½•
                const url = analysis.basicInfo?.url || '';
                const title = analysis.basicInfo?.title || file.name;
                const supplementText = document.getElementById('supplementDataInput').value.trim();
                saveToHistory(file.name, url, title, {
                    analysis: analysis,
                    supplementInfo: supplementInfo
                }, supplementText);

                displayResults(analysis, supplementInfo);
            } catch (error) {
                showError('æ–‡ä»¶è¯»å–å¤±è´¥');
            } finally {
                showLoading(false);
            }
        }



        function analyzePage(html, url) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');

            const analysis = {
                url: url,
                title: '',
                description: '',
                h1: [],
                headings: [],
                wordCount: 0,
                charCount: 0,
                keywords: {},
                images: 0,
                links: 0
            };

            // åŸºç¡€ä¿¡æ¯
            const titleEl = doc.querySelector('title');
            analysis.title = titleEl ? titleEl.textContent.trim() : '';

            const descEl = doc.querySelector('meta[name="description"]');
            analysis.description = descEl ? descEl.getAttribute('content').trim() : '';

            const h1Elements = doc.querySelectorAll('h1');
            analysis.h1 = Array.from(h1Elements).map(el => el.textContent.trim()).filter(text => text);

            // æ ‡é¢˜ç»“æ„ (H1-H2æ ‡ç­¾æŒ‰é¡µé¢å‡ºç°é¡ºåºå±•ç¤º)
            const allHeadings = doc.querySelectorAll('h1, h2');
            analysis.headings = Array.from(allHeadings).map(heading => {
                const level = parseInt(heading.tagName.substring(1));
                const text = heading.textContent.trim();
                return { level, text };
            }).filter(heading => heading.text);

            // æ–‡æœ¬åˆ†æ - åªåˆ†æå¯è§æ–‡æœ¬å†…å®¹ï¼Œæ’é™¤è„šæœ¬å’Œæ ·å¼
            let visibleText = '';

            // è·å–æ‰€æœ‰å¯è§çš„æ–‡æœ¬èŠ‚ç‚¹
            const getVisibleText = (element) => {
                let text = '';

                if (!element) return text;

                // è·³è¿‡ä¸å¯è§å…ƒç´ 
                const tagName = element.tagName ? element.tagName.toLowerCase() : '';
                if (['script', 'style', 'noscript', 'meta', 'link', 'head'].includes(tagName)) {
                    return text;
                }

                // å¦‚æœæ˜¯æ–‡æœ¬èŠ‚ç‚¹
                if (element.nodeType === Node.TEXT_NODE) {
                    return element.textContent.trim();
                }

                // é€’å½’å¤„ç†å­èŠ‚ç‚¹
                for (const child of element.childNodes) {
                    text += ' ' + getVisibleText(child);
                }

                return text;
            };

            visibleText = getVisibleText(doc.body || doc);
            const cleanText = visibleText.replace(/\s+/g, ' ').trim();

            analysis.wordCount = cleanText ? cleanText.split(' ').filter(word => word.length > 0).length : 0;
            analysis.charCount = cleanText.length;

            // å…³é”®è¯åˆ†æ - åªåˆ†æå¯è§æ–‡æœ¬å†…å®¹
            if (cleanText) {
                const words = cleanText.toLowerCase()
                    .replace(/[^\w\s\u4e00-\u9fff]/g, ' ')
                    .split(/\s+/)
                    .filter(word => word.length >= 2);

                // å•è¯
                const singleWords = {};
                words.forEach(word => {
                    singleWords[word] = (singleWords[word] || 0) + 1;
                });

                // 2è¯ç»„åˆ
                const twoWordPhrases = {};
                for (let i = 0; i < words.length - 1; i++) {
                    const phrase = `${words[i]} ${words[i + 1]}`;
                    twoWordPhrases[phrase] = (twoWordPhrases[phrase] || 0) + 1;
                }

                // 3è¯ç»„åˆ
                const threeWordPhrases = {};
                for (let i = 0; i < words.length - 2; i++) {
                    const phrase = `${words[i]} ${words[i + 1]} ${words[i + 2]}`;
                    threeWordPhrases[phrase] = (threeWordPhrases[phrase] || 0) + 1;
                }

                // 4è¯ç»„åˆ
                const fourWordPhrases = {};
                for (let i = 0; i < words.length - 3; i++) {
                    const phrase = `${words[i]} ${words[i + 1]} ${words[i + 2]} ${words[i + 3]}`;
                    fourWordPhrases[phrase] = (fourWordPhrases[phrase] || 0) + 1;
                }


                const processKeywords = (wordFreq, totalCount, limit = 5) => {
                    return Object.entries(wordFreq)
                        .filter(([word, count]) => count > 1)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, limit)
                        .map(([word, count]) => ({
                            word,
                            count,
                            density: ((count / totalCount) * 100).toFixed(2)
                        }));
                };

                analysis.keywords = {
                    single: processKeywords(singleWords, words.length, 5),
                    double: processKeywords(twoWordPhrases, words.length - 1, 5),
                    triple: processKeywords(threeWordPhrases, words.length - 2, 5),
                    quadruple: processKeywords(fourWordPhrases, words.length - 3, 5)
                };
            }

            analysis.images = doc.querySelectorAll('img').length;
            analysis.links = doc.querySelectorAll('a').length;

            return analysis;
        }

        function displayResults(analysis, supplementInfo = null) {
            // åŸºç¡€ä¿¡æ¯å’Œå…³é”®è¯ä¿¡æ¯
            const basicInfoDiv = document.getElementById('basicInfo');
            let basicInfoHTML = '';

            // å¦‚æœæœ‰å…³é”®è¯ä¿¡æ¯ï¼Œå…ˆæ˜¾ç¤ºå…³é”®è¯å’ŒURL
            if (supplementInfo && supplementInfo.keywordInfo) {
                const kw = supplementInfo.keywordInfo;
                basicInfoHTML += `
                    <div class="meta-item">
                        <div class="meta-label">å…³é”®è¯ï¼š<span style="font-weight: normal; color: #202020; margin-left: 8px;">${kw.keyword}</span></div>
                    </div>
                    <div class="meta-item">
                        <div class="meta-label">URLï¼š<span style="font-weight: normal; margin-left: 8px;"><a href="${kw.url}" target="_blank" style="color: #644a40; text-decoration: underline; word-break: break-all; font-size: 12px;">${kw.url}</a></span></div>
                    </div>
                `;

                // åªåœ¨æœç´¢é‡ä¸ä¸º0æ—¶æ˜¾ç¤º
                if (kw.searchVolume && parseInt(kw.searchVolume) > 0) {
                    basicInfoHTML += `
                        <div class="meta-item">
                            <div class="meta-label">æœç´¢é‡ï¼š<span style="font-weight: normal; color: #202020; margin-left: 8px;">${parseInt(kw.searchVolume).toLocaleString()}</span></div>
                        </div>
                    `;
                }

                basicInfoHTML += `
                    <div class="meta-item">
                        <div class="meta-label">è·å¾—æµé‡ï¼š<span style="font-weight: normal; color: #202020; margin-left: 8px;">${kw.traffic}</span></div>
                    </div>
                `;
            }

            basicInfoDiv.innerHTML = basicInfoHTML;


            // æ ‡é¢˜ç»“æ„ (æ–‡ç« å¤§çº²é£æ ¼)
            const headingsDiv = document.getElementById('headingsInfo');
            if (analysis.headings.length > 0) {
                headingsDiv.innerHTML = analysis.headings.map(heading => `
                    <div class="heading-item h${heading.level}">
                        <span class="heading-level">H${heading.level}</span>
                        <span class="heading-text">${heading.text}</span>
                    </div>
                `).join('');
            } else {
                headingsDiv.innerHTML = '<div class="no-data">æœªæ‰¾åˆ°æ ‡é¢˜æ ‡ç­¾</div>';
            }

            // å…³é”®è¯å¯†åº¦
            const keywordsDiv = document.getElementById('keywordsInfo');
            if (analysis.keywords && Object.values(analysis.keywords).some(arr => arr.length > 0)) {
                const generateKeywordCategory = (keywords, title) => {
                    if (keywords.length === 0) {
                        return `
                            <div class="keyword-category">
                                <div class="keyword-category-header">${title}</div>
                                <div class="no-data">æš‚æ— æ•°æ®</div>
                            </div>
                        `;
                    }
                    
                    const keywordItems = keywords.map(keyword => `
                        <div class="keyword-item">
                            <div class="keyword-text">${keyword.word}</div>
                            <span class="keyword-count">${keyword.count}æ¬¡</span>
                        </div>
                    `).join('');

                    return `
                        <div class="keyword-category">
                            <div class="keyword-category-header">${title}</div>
                            <div class="keyword-list">${keywordItems}</div>
                        </div>
                    `;
                };

                keywordsDiv.innerHTML = `
                    ${generateKeywordCategory(analysis.keywords.single, '1è¯')}
                    ${generateKeywordCategory(analysis.keywords.double, '2è¯')}
                    ${generateKeywordCategory(analysis.keywords.triple, '3è¯')}
                    ${generateKeywordCategory(analysis.keywords.quadruple, '4è¯')}
                `;
            } else {
                keywordsDiv.innerHTML = '<div class="no-data">æœªæ‰¾åˆ°å…³é”®è¯æ•°æ®</div>';
            }

            // æ˜¾ç¤ºé¡µé¢æ ‡é¢˜å’Œæè¿°
            const titleDescDiv = document.getElementById('titleDescriptionInfo');
            titleDescDiv.innerHTML = `
                <div class="meta-item" style="margin-bottom: 8px;">
                    <div class="meta-label">é¡µé¢æ ‡é¢˜${getStatusBadge(analysis.title, 'title')}</div>
                    <div class="meta-value">${analysis.title || 'æœªæ‰¾åˆ°'}</div>
                </div>
                <div class="meta-item">
                    <div class="meta-label">é¡µé¢æè¿°${getStatusBadge(analysis.description, 'description')}</div>
                    <div class="meta-value">${analysis.description || 'æœªæ‰¾åˆ°'}</div>
                </div>
            `;

            // æ˜¾ç¤ºå…³é”®è¯æŒ‡æ ‡
            const keywordMetricsDiv = document.getElementById('keywordMetrics');
            if (supplementInfo && supplementInfo.keywordInfo) {
                displayKeywordMetrics(supplementInfo.keywordInfo, keywordMetricsDiv);
            } else {
                keywordMetricsDiv.innerHTML = '';
            }

            // æ˜¾ç¤ºè¡¥å……ä¿¡æ¯
            const supplementCard = document.getElementById('supplementCard');
            const supplementDiv = document.getElementById('supplementInfo');
            if (supplementInfo && supplementInfo.serpLinks && supplementInfo.serpLinks.length > 0) {
                displaySupplementInfo(supplementInfo, supplementDiv);
                supplementCard.style.display = 'block';
            } else {
                supplementCard.style.display = 'none';
            }

            // æ›´æ–°å•è¯æ•°æ˜¾ç¤º
            const wordCountDisplay = document.getElementById('wordCountDisplay');
            if (wordCountDisplay) {
                wordCountDisplay.textContent = analysis.wordCount;
            }

            document.getElementById('results').style.display = 'block';
        }

        function getStatusBadge(value, type) {
            switch (type) {
                case 'title':
                    if (!value) return '<span class="status error">ç¼ºå¤±</span>';
                    if (value.length < 30) return '<span class="status warning">åçŸ­</span>';
                    if (value.length > 60) return '<span class="status warning">åé•¿</span>';
                    return '<span class="status good">è‰¯å¥½</span>';
                
                case 'description':
                    if (!value) return '<span class="status error">ç¼ºå¤±</span>';
                    if (value.length < 120) return '<span class="status warning">åçŸ­</span>';
                    if (value.length > 160) return '<span class="status warning">åé•¿</span>';
                    return '<span class="status good">è‰¯å¥½</span>';
                
                case 'h1':
                    if (!value || value.length === 0) return '<span class="status error">ç¼ºå¤±</span>';
                    if (value.length > 1) return '<span class="status warning">å¤šä¸ªH1</span>';
                    return '<span class="status good">è‰¯å¥½</span>';
                
                default:
                    return '';
            }
        }

        async function batchDownload() {
            const textarea = document.getElementById('batchUrls');
            const progressDiv = document.getElementById('batchProgress');
            const batchBtn = document.getElementById('batchBtn');
            
            const urls = textarea.value
                .split('\n')
                .map(url => url.trim())
                .filter(url => url && url.startsWith('http'));

            if (urls.length === 0) {
                showError('è¯·è¾“å…¥æœ‰æ•ˆçš„ç½‘å€åˆ—è¡¨');
                return;
            }

            progressDiv.style.display = 'block';
            batchBtn.disabled = true;
            batchBtn.textContent = 'ä¸‹è½½ä¸­...';

            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            const progressCount = document.getElementById('progressCount');
            const progressDetails = document.getElementById('progressDetails');

            let completed = 0;
            let successful = 0;
            const results = [];

            progressCount.textContent = `0/${urls.length}`;
            progressDetails.innerHTML = '';

            try {
                progressText.textContent = `å¼€å§‹å¹¶å‘ä¸‹è½½ ${urls.length} ä¸ªé“¾æ¥...`;

                // åˆ›å»ºæ‰€æœ‰ä¸‹è½½ä»»åŠ¡
                const downloadTasks = urls.map(async (url, i) => {
                    try {
                        const response = await fetchPageContent(url, 12000); // 12ç§’è¶…æ—¶
                        const html = await response.text();

                        const urlObj = new URL(url);
                        const filename = `${urlObj.hostname}.html`;

                        downloadHTML(html, filename);
                        return { url, status: 'success', filename, html };
                    } catch (error) {
                        console.error(`ä¸‹è½½å¤±è´¥ ${url}:`, error);
                        return { url, status: 'failed', error: error.message };
                    }
                });

                // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆï¼Œå¹¶å®æ—¶æ›´æ–°è¿›åº¦
                for (let taskIndex = 0; taskIndex < downloadTasks.length; taskIndex++) {
                    const task = downloadTasks[taskIndex];
                    const result = await task;
                    results.push(result);
                    completed++;

                    if (result.status === 'success') {
                        successful++;
                        progressDetails.innerHTML += `<div style="color: #644a40;">âœ“ ${result.url}</div>`;
                    } else {
                        progressDetails.innerHTML += `<div style="color: #e54d2e;">âœ— ${result.url} (${result.error})</div>`;
                    }

                    progressCount.textContent = `${completed}/${urls.length}`;
                    progressFill.style.width = `${(completed / urls.length) * 100}%`;
                    progressText.textContent = `å·²å®Œæˆ: ${completed}/${urls.length}`;
                }

                progressText.textContent = `æ‰¹é‡ä¸‹è½½å®Œæˆï¼æˆåŠŸ: ${successful}ä¸ª`;
                
                // æ‰¹é‡ä¸‹è½½åè‡ªåŠ¨åˆ†æç¬¬ä¸€ä¸ªæˆåŠŸçš„æ–‡ä»¶
                if (results.length > 0) {
                    const successResult = results.find(r => r.status === 'success');
                    if (successResult) {
                        setTimeout(() => {
                            const analysis = analyzePage(successResult.html, successResult.url);

                            // æ£€æŸ¥æ˜¯å¦æœ‰è¡¥å……ä¿¡æ¯
                            const supplementData = document.getElementById('supplementDataInput').value.trim();
                            let supplementInfo = null;
                            if (supplementData) {
                                try {
                                    supplementInfo = parseKeywordAndSerpData(supplementData);
                                } catch (error) {
                                    console.warn('è¡¥å……ä¿¡æ¯è§£æå¤±è´¥', error);
                                }
                            }

                            displayResults(analysis, supplementInfo);
                        }, 1000);
                    }
                }
                
            } catch (error) {
                showError('æ‰¹é‡ä¸‹è½½å¤±è´¥: ' + error.message);
            } finally {
                batchBtn.disabled = false;
                batchBtn.textContent = 'æ‰¹é‡ä¸‹è½½';
            }
        }

        function downloadHTML(htmlContent, filename) {
            const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function showLoading(show) {
            document.querySelector('.loading').style.display = show ? 'block' : 'none';
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 5000);
        }

        function parseSupplementData() {
            const textarea = document.getElementById('supplementData');
            const supplementInfo = document.getElementById('supplementInfo');
            const data = textarea.value.trim();

            if (!data) {
                showError('è¯·è¾“å…¥è¡¥å……æ•°æ®');
                return;
            }

            try {
                const result = parseKeywordAndSerpData(data);
                displaySupplementInfo(result);
                supplementInfo.style.display = 'block';
            } catch (error) {
                showError('æ•°æ®è§£æå¤±è´¥ï¼Œè¯·æ£€æŸ¥æ•°æ®æ ¼å¼');
            }
        }

        function parseKeywordAndSerpData(data) {
            console.log('Starting to parse supplement data');
            const lines = data.split('\n').filter(line => line.trim());
            const result = {
                keywordInfo: null,
                serpLinks: []
            };

            let currentSection = '';
            let keywordHeaderFound = false;
            let serpLinksStarted = false;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();

                // æ£€æŸ¥æ˜¯å¦æ˜¯å…³é”®è¯ä¿¡æ¯å¼€å§‹
                if (line.includes('å…³é”®è¯ä¿¡æ¯') || line.toLowerCase().includes('keyword')) {
                    currentSection = 'keyword';
                    continue;
                }

                // æ£€æŸ¥æ˜¯å¦æ˜¯SERPé“¾æ¥å¼€å§‹
                if (line.includes('SERP links') || (line.includes('URL') && line.includes('ç½‘ç«™æ ‡é¢˜'))) {
                    currentSection = 'serp';
                    serpLinksStarted = true;
                    continue;
                }

                // å¦‚æœæ²¡æœ‰æ‰¾åˆ°å…³é”®è¯æ•°æ®ï¼Œå¹¶ä¸”å½“å‰è¡Œä¸æ˜¯tabåˆ†éš”çš„æ•°æ®ï¼Œæ£€æŸ¥æ˜¯å¦æ˜¯Googleæ ¼å¼SERPå¼€å§‹
                if (currentSection === '' && !keywordHeaderFound && !line.includes('\t')) {
                    // æ£€æŸ¥æ¥ä¸‹æ¥å‡ è¡Œæ˜¯å¦ç¬¦åˆGoogleæ ¼å¼
                    let hasGoogleFormat = false;
                    for (let j = i + 1; j < Math.min(i + 6, lines.length); j++) {
                        const checkLine = lines[j] ? lines[j].trim() : '';
                        if (checkLine.includes('â€º') || checkLine.startsWith('http')) {
                            hasGoogleFormat = true;
                            break;
                        }
                    }

                    if (hasGoogleFormat) {
                        currentSection = 'serp';
                        serpLinksStarted = true;
                        // ä¸è¦å›é€€ï¼Œç›´æ¥å¤„ç†å½“å‰è¡Œ
                    }
                }

                // è§£æå…³é”®è¯æ•°æ®
                if (currentSection === 'keyword' && line.includes('\t') && !keywordHeaderFound) {
                    const parts = line.split('\t');

                    // è·³è¿‡è¡¨å¤´è¡Œ
                    if (line.toLowerCase().includes('keyword') && line.toLowerCase().includes('difficulty')) {
                        continue;
                    }

                    // è§£ææ•°æ®è¡Œ
                    if (parts.length >= 13) {
                        // æŒ‰ç…§å®é™…æ ¼å¼è§£æï¼š
                        // 0:Keyword, 1:Position, 2:Previous position, 3:Search Volume, 4:Keyword Difficulty, 5:CPC, 6:URL, 7:Traffic, 8:Traffic (%), 9:Traffic Cost, 10:Competition, 11:Number of Results, 12:intitle
                        result.keywordInfo = {
                            keyword: parts[0] || '',
                            position: parts[1] || '',
                            difficulty: parts[4] || '',
                            results: parts[11] || '', // Number of Results
                            intitle: parts[12] || '', // intitle ç»“æœæ•°
                            url: parts[6] || '',
                            traffic: parts[7] || ''
                        };
                        keywordHeaderFound = true;
                        console.log('Successfully parsed keyword info:', result.keywordInfo);
                    } else {
                        console.log('Not enough parts for keyword parsing:', parts.length);
                    }
                }

                // è§£æSERPé“¾æ¥
                if (currentSection === 'serp' && serpLinksStarted) {
                    // å¦‚æœæ˜¯ç©ºè¡Œï¼Œè·³è¿‡
                    if (!line) {
                        continue;
                    }

                    // æ£€æŸ¥æ¥ä¸‹æ¥å‡ è¡Œæ˜¯å¦ç¬¦åˆGoogleæ ¼å¼
                    let isGoogleFormat = false;
                    for (let j = i + 1; j <= i + 4 && j < lines.length; j++) {
                        const nextLine = lines[j].trim();
                        if (nextLine.includes('â€º')) {
                            isGoogleFormat = true;
                            break;
                        }
                    }

                    if (isGoogleFormat) {
                        // Googleæ ¼å¼ï¼šè§£æä»å½“å‰ä½ç½®å¼€å§‹çš„æ‰€æœ‰æ•°æ®
                        const googleResults = parseGoogleFormat(lines, i);
                        if (googleResults.length > 0) {
                            result.serpLinks.push(...googleResults);
                        }
                        break; // å·²è§£æå®Œæ‰€æœ‰Googleæ ¼å¼æ•°æ®
                    } else if (line.includes('http')) {
                        // åŸæœ‰æ ¼å¼
                        const parsed = parseSerpLine(line);
                        if (parsed) {
                            result.serpLinks.push(parsed);
                        }
                    }
                }
            }

            console.log('Parsing completed. Found', result.serpLinks.length, 'SERP links');
            return result;
        }

        function parseGoogleFormat(lines, startIndex) {
            // Googleæœç´¢ç»“æœæ ¼å¼è§£æ
            // æ ¼å¼ï¼šç¬¬1è¡Œ-æ ‡é¢˜ï¼Œç¬¬2è¡Œ-ç½‘ç«™åï¼Œç¬¬3è¡Œ-URLï¼Œç¬¬4è¡Œ-æè¿°

            const results = [];
            let i = startIndex;

            while (i < lines.length - 2) {  // è‡³å°‘éœ€è¦3è¡Œæ‰èƒ½å½¢æˆä¸€ä¸ªæ¡ç›®
                const line1 = lines[i] ? lines[i].trim() : '';
                const line2 = lines[i + 1] ? lines[i + 1].trim() : '';
                const line3 = lines[i + 2] ? lines[i + 2].trim() : '';
                const line4 = lines[i + 3] ? lines[i + 3].trim() : '';

                console.log(`Checking entry starting at line ${i}:`);
                console.log(`  Line ${i}: "${line1}" (potential title)`);
                console.log(`  Line ${i + 1}: "${line2}" (potential website)`);
                console.log(`  Line ${i + 2}: "${line3}" (potential URL)`);
                console.log(`  Line ${i + 3}: "${line4}" (potential description)`);

                // æ£€æŸ¥æ˜¯å¦ç¬¦åˆGoogleæ ¼å¼ï¼šç¬¬3è¡ŒåŒ…å«â€ºç¬¦å·
                if (line3.includes('â€º')) {
                    let title = line1;
                    let url = line3.replace(/\s*â€º\s*/g, '/');
                    url = url.replace(/\s+/g, '');

                    if (!url.startsWith('http')) {
                        url = 'https://' + url;
                    }

                    if (title && url) {
                        results.push({
                            title: title,
                            url: url
                        });
                        console.log(`  âœ“ Added result: title="${title}", url="${url}"`);

                        // è·³è¿‡è¿™ä¸ªå®Œæ•´çš„æ¡ç›®ï¼ˆ4è¡Œï¼‰
                        i += 4;

                        // è·³è¿‡å¯èƒ½çš„ç©ºè¡Œ
                        while (i < lines.length && !lines[i].trim()) {
                            i++;
                        }
                    } else {
                        i++;
                    }
                } else {
                    // ä¸ç¬¦åˆæ ¼å¼ï¼Œç»§ç»­ä¸‹ä¸€è¡Œ
                    i++;
                }
            }

            return results;
        }

        function parseSerpLine(line) {
            // ç¤ºä¾‹æ ¼å¼ï¼šhttps://funy.ai/ai-video/clipfly-ai-kissing-generator-free/#:~:text=Merge%20t...1ClipFly AI Kissing Generator: Create Free Kiss Videos - Funy AIFuny AIhttps:...
            // æˆ–ï¼šhttps://funy.ai/ai-kissing-video-free/2AI Kissing Video Generator Online - Free & No Sign UpFuny AIhttps://funy.ai ...

            // æå–å¼€å¤´çš„URL
            const urlMatch = line.match(/^(https?:\/\/[^\s#]*[^\d])/);
            if (!urlMatch) return null;

            const url = urlMatch[1];
            let remainingText = line.replace(urlMatch[0], '').trim();

            // ç§»é™¤å¼€å¤´å¯èƒ½çš„åºå·
            remainingText = remainingText.replace(/^\d+/, '').trim();

            // æŸ¥æ‰¾æ ‡é¢˜ï¼šä»åºå·ååˆ°"https"ä¹‹å‰çš„å†…å®¹
            let title = '';
            const httpsIndex = remainingText.indexOf('https');
            if (httpsIndex > 0) {
                title = remainingText.substring(0, httpsIndex).trim();
            } else {
                title = remainingText;
            }

            // æ¸…ç†æ ‡é¢˜ï¼Œç§»é™¤å¤šä½™çš„ç½‘ç«™åç§°é‡å¤
            title = title.replace(/([A-Za-z\s]+)\1+$/, '$1'); // ç§»é™¤é‡å¤çš„ç½‘ç«™å
            title = title.replace(/\s+/g, ' ').trim(); // è§„èŒƒåŒ–ç©ºæ ¼

            if (!title) return null;

            return {
                url: url,
                title: title
            };
        }

        function handleFileSelect(input) {
            if (input.files && input.files[0]) {
                const file = input.files[0];
                updateFileStatus(file.name);
            }
        }

        function displayKeywordMetrics(keywordInfo, targetDiv) {
            const kw = keywordInfo;
            const results = parseFloat(kw.results) || 0;
            const intitle = parseFloat(kw.intitle) || 0;
            const difficulty = parseFloat(kw.difficulty) || 0;
            const traffic = parseFloat(kw.traffic) || 0;

            // è®¡ç®— KGR (Keyword Golden Ratio) = intitle / Number of Results
            let kgr = 0;
            let kgrStatus = '';
            if (results > 0) {
                kgr = (intitle / results).toFixed(4);
                if (kgr <= 0.25) kgrStatus = 'ğŸŸ¢ ä¼˜ç§€';
                else if (kgr <= 0.5) kgrStatus = 'ğŸŸ¡ è‰¯å¥½';
                else if (kgr <= 1) kgrStatus = 'ğŸŸ  ä¸€èˆ¬';
                else kgrStatus = 'ğŸ”´ è¾ƒå·®';
            } else {
                kgr = 'N/A';
                kgrStatus = 'æ— æ³•è®¡ç®—';
            }

            targetDiv.innerHTML = `
                <h3 style="color: #644a40; margin-bottom: 8px; font-size: 1em;">å…³é”®è¯æŒ‡æ ‡</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)); gap: 8px;">
                    <div style="background: #f5f5f5; padding: 8px; border-radius: 4px; text-align: center;">
                        <div style="font-size: 12px; color: #666;">æœç´¢ç»“æœæ•°é‡</div>
                        <div style="font-weight: 600; color: #644a40; font-size: 14px;">${kw.results ? parseInt(kw.results).toLocaleString() : '0'}</div>
                    </div>
                    <div style="background: #f5f5f5; padding: 8px; border-radius: 4px; text-align: center;">
                        <div style="font-size: 12px; color: #666;">Intitle</div>
                        <div style="font-weight: 600; color: #644a40; font-size: 14px;">${kw.intitle ? parseInt(kw.intitle).toLocaleString() : '0'}</div>
                    </div>
                    <div style="background: #f5f5f5; padding: 8px; border-radius: 4px; text-align: center;">
                        <div style="font-size: 12px; color: #666;">KDéš¾åº¦</div>
                        <div style="font-weight: 600; color: #644a40; font-size: 14px;">${kw.difficulty}</div>
                    </div>
                    <div style="background: #f5f5f5; padding: 8px; border-radius: 4px; text-align: center;">
                        <div style="font-size: 12px; color: #666;">KGR</div>
                        <div style="font-weight: 600; color: #644a40; font-size: 14px;">${kgr}</div>
                    </div>
                </div>
            `;
        }

        function displaySupplementInfo(data) {
            const supplementDiv = document.getElementById('supplementInfo');
            let html = '';

            // ä¿å­˜SERPé“¾æ¥æ•°æ®åˆ°å…¨å±€å˜é‡
            globalSerpLinks = data.serpLinks || [];


            // SERPé“¾æ¥è¡¨æ ¼ï¼ˆæ— æ ‡é¢˜ï¼‰
            if (data.serpLinks.length > 0) {
                html += `
                    <div style="overflow-x: auto;">
                        <table style="width: 100%; border-collapse: collapse; background: #fcfcfc; border: 1px solid #d8d8d8; border-radius: 6px;">
                            <thead>
                                <tr style="background: #efefef;">
                                    <th style="padding: 8px; text-align: left; border-bottom: 1px solid #d8d8d8; color: #644a40; font-weight: 600; font-size: 14px;">#</th>
                                    <th style="padding: 8px; text-align: left; border-bottom: 1px solid #d8d8d8; color: #644a40; font-weight: 600; font-size: 14px;">æ ‡é¢˜</th>
                                    <th style="padding: 8px; text-align: left; border-bottom: 1px solid #d8d8d8; color: #644a40; font-weight: 600; font-size: 14px;">ç½‘å€</th>
                                </tr>
                            </thead>
                            <tbody>
                `;

                data.serpLinks.forEach((link, index) => {
                    html += `
                        <tr style="border-bottom: 1px solid #e8e8e8;" id="serp-row-${index}">
                            <td style="padding: 8px; font-weight: 600; color: #644a40; font-size: 14px; line-height: 1.3;">${index + 1}</td>
                            <td style="padding: 8px; color: #202020; line-height: 1.3; font-size: 14px;">${link.title}</td>
                            <td style="padding: 8px; font-size: 14px; line-height: 1.3;">
                                <a href="${link.url}" target="_blank" style="color: #644a40; text-decoration: underline; word-break: break-all;">${link.url}</a>
                                <span id="download-status-${index}" style="margin-left: 8px; color: #28a745; font-weight: bold;"></span>
                            </td>
                        </tr>
                    `;
                });

                html += `
                            </tbody>
                        </table>
                    </div>
                `;
            }

            supplementDiv.innerHTML = html;
        }

        function testParseData() {
            const data = document.getElementById('supplementDataInput').value.trim();
            if (!data) {
                alert('è¯·å…ˆè¾“å…¥è¡¥å……æ•°æ®');
                return;
            }

            console.log('=== å¼€å§‹æµ‹è¯•è§£æ ===');
            try {
                const result = parseKeywordAndSerpData(data);
                console.log('=== è§£æç»“æœ ===', result);
                alert(`è§£æç»“æœï¼š\nå…³é”®è¯: ${result.keywordInfo?.keyword || 'æœªæ‰¾åˆ°'}\nç»“æœæ•°: ${result.keywordInfo?.results || 'æœªæ‰¾åˆ°'}\nSERPé“¾æ¥: ${result.serpLinks?.length || 0}ä¸ª\n\nè¯·æŸ¥çœ‹æ§åˆ¶å°è·å–è¯¦ç»†ä¿¡æ¯`);
            } catch (error) {
                console.error('è§£æå¤±è´¥:', error);
                alert('è§£æå¤±è´¥ï¼Œè¯·æŸ¥çœ‹æ§åˆ¶å°è·å–è¯¦ç»†ä¿¡æ¯');
            }
        }

        // å…¨å±€å˜é‡å­˜å‚¨SERPé“¾æ¥æ•°æ®
        let globalSerpLinks = [];

        // æ•°æ®æŒä¹…åŒ–ç›¸å…³å‡½æ•°
        const STORAGE_KEY = 'seo_analyzer_data';
        const HISTORY_KEY = 'seo_analyzer_history';
        const STORAGE_EXPIRY_DAYS = 7;
        const MAX_HISTORY_RECORDS = 10;

        function saveToStorage(data) {
            try {
                const storageData = {
                    ...data,
                    timestamp: Date.now(),
                    expiryTime: Date.now() + (STORAGE_EXPIRY_DAYS * 24 * 60 * 60 * 1000)
                };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(storageData));
                console.log('æ•°æ®å·²ä¿å­˜åˆ°localStorage:', Object.keys(data));
            } catch (error) {
                console.warn('ä¿å­˜åˆ°localStorageå¤±è´¥:', error);
            }
        }

        function loadFromStorage() {
            try {
                const stored = localStorage.getItem(STORAGE_KEY);
                if (!stored) return null;

                const data = JSON.parse(stored);

                // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
                if (data.expiryTime && Date.now() > data.expiryTime) {
                    localStorage.removeItem(STORAGE_KEY);
                    console.log('localStorageæ•°æ®å·²è¿‡æœŸï¼Œå·²æ¸…é™¤');
                    return null;
                }

                return data;
            } catch (error) {
                console.warn('ä»localStorageè¯»å–å¤±è´¥:', error);
                return null;
            }
        }

        function clearStorage() {
            localStorage.removeItem(STORAGE_KEY);
            console.log('localStorageæ•°æ®å·²æ¸…é™¤');
        }

        function saveFileData(fileName, fileContent, analysisResult = null) {
            const currentData = loadFromStorage() || {};
            const fileData = {
                uploadedFile: {
                    name: fileName,
                    content: fileContent,
                    uploadTime: Date.now()
                }
            };

            if (analysisResult) {
                fileData.analysisResults = analysisResult;
            }

            saveToStorage({
                ...currentData,
                ...fileData
            });
        }

        function saveSupplementData(supplementText, parsedData = null) {
            const currentData = loadFromStorage() || {};
            const supplementData = {
                supplementData: supplementText
            };

            if (parsedData) {
                supplementData.parsedSupplementData = parsedData;
            }

            saveToStorage({
                ...currentData,
                ...supplementData
            });
        }

        // å®æ—¶ä¿å­˜è¡¥å……ä¿¡æ¯
        let saveTimeout;
        function saveSupplementDataOnInput() {
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => {
                const supplementText = document.getElementById('supplementDataInput').value.trim();
                if (supplementText) {
                    try {
                        const parsedData = parseKeywordAndSerpData(supplementText);
                        saveSupplementData(supplementText, parsedData);
                    } catch (error) {
                        saveSupplementData(supplementText);
                    }
                }
            }, 1000); // 1ç§’åä¿å­˜ï¼Œé¿å…é¢‘ç¹ä¿å­˜
        }

        // é¡µé¢åŠ è½½æ—¶æ¢å¤æ•°æ®
        let dataRestored = false;
        function restoreDataOnLoad() {
            if (dataRestored) return; // é˜²æ­¢é‡å¤æ¢å¤

            const savedData = loadFromStorage();
            if (!savedData) return;

            console.log('æ¢å¤localStorageæ•°æ®');
            let hasRestored = false;

            // æ¢å¤ä¸Šä¼ çš„æ–‡ä»¶ä¿¡æ¯å’Œåˆ†æç»“æœ
            if (savedData.uploadedFile) {
                // åˆ›å»ºæ–‡ä»¶çŠ¶æ€æŒ‡ç¤ºå™¨
                createFileStatusIndicator(savedData.uploadedFile.name);

                // å¦‚æœæœ‰åˆ†æç»“æœï¼Œç›´æ¥æ˜¾ç¤º
                if (savedData.analysisResults) {
                    displayResults(savedData.analysisResults.analysis, savedData.analysisResults.supplementInfo);
                    hasRestored = true;
                }
            }

            // æ¢å¤è¡¥å……ä¿¡æ¯
            if (savedData.supplementData) {
                const supplementInput = document.getElementById('supplementDataInput');
                if (supplementInput) {
                    supplementInput.value = savedData.supplementData;
                    hasRestored = true;
                }
            }

            // æ˜¾ç¤ºæ¢å¤æç¤º
            if (hasRestored) {
                showRestoreNotification();
            }

            dataRestored = true; // æ ‡è®°å·²æ¢å¤
        }

        function createFileStatusIndicator(fileName) {
            // åœ¨æ–‡ä»¶è¾“å…¥æ¡†ä¸‹æ–¹æ˜¾ç¤ºå·²æ¢å¤çš„æ–‡ä»¶çŠ¶æ€
            const fileInput = document.getElementById('fileInput');
            let statusDiv = document.getElementById('fileRestoreStatus');

            if (!statusDiv) {
                statusDiv = document.createElement('div');
                statusDiv.id = 'fileRestoreStatus';
                fileInput.parentNode.insertBefore(statusDiv, fileInput.nextSibling);
            }

            statusDiv.innerHTML = `
                <div style="padding: 8px 12px; background: #e8f5e8; border: 1px solid #c3e6c3; border-radius: 4px; margin-top: 8px; font-size: 13px; color: #2d5a2d;">
                    âœ“ å·²æ¢å¤æ–‡ä»¶: <strong>${fileName}</strong>
                    <button onclick="clearRestoredFile()" style="background: none; border: none; color: #dc3545; margin-left: 10px; cursor: pointer; font-size: 12px;">æ¸…é™¤</button>
                </div>
            `;
        }

        function clearRestoredFile() {
            const statusDiv = document.getElementById('fileRestoreStatus');
            if (statusDiv) {
                statusDiv.remove();
            }

            // æ¸…é™¤localStorageä¸­çš„æ–‡ä»¶æ•°æ®
            const currentData = loadFromStorage();
            if (currentData) {
                delete currentData.uploadedFile;
                delete currentData.analysisResults;
                saveToStorage(currentData);
            }

            // éšè—åˆ†æç»“æœ
            document.getElementById('results').style.display = 'none';
        }

        function showRestoreNotification(message = 'å·²æ¢å¤ä¹‹å‰çš„æ•°æ®') {
            const notification = document.createElement('div');
            notification.innerHTML = `
                <div style="position: fixed; top: 20px; right: 20px; background: #28a745; color: white; padding: 12px 16px; border-radius: 6px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 1000; font-size: 14px;">
                    âœ“ ${message}
                    <button onclick="this.parentElement.remove()" style="background: none; border: none; color: white; margin-left: 10px; cursor: pointer; font-size: 16px;">Ã—</button>
                </div>
            `;
            document.body.appendChild(notification);

            // 3ç§’åè‡ªåŠ¨æ¶ˆå¤±
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.remove();
                }
            }, 3000);
        }

        // æ¸…é™¤ç¼“å­˜æ•°æ®
        function clearCacheData() {
            clearStorage();

            // æ¸…é™¤ç•Œé¢
            document.getElementById('fileInput').value = '';
            document.getElementById('supplementDataInput').value = '';
            document.getElementById('results').style.display = 'none';

            // æ¸…é™¤æ–‡ä»¶æ¢å¤çŠ¶æ€æŒ‡ç¤ºå™¨
            const statusDiv = document.getElementById('fileRestoreStatus');
            if (statusDiv) {
                statusDiv.remove();
            }

            // æ˜¾ç¤ºæ¸…é™¤æˆåŠŸæç¤º
            showClearNotification();
        }

        function showClearNotification() {
            const notification = document.createElement('div');
            notification.innerHTML = `
                <div style="position: fixed; top: 20px; right: 20px; background: #dc3545; color: white; padding: 12px 16px; border-radius: 6px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 1000; font-size: 14px;">
                    ğŸ—‘ï¸ ç¼“å­˜æ•°æ®å·²æ¸…é™¤
                    <button onclick="this.parentElement.remove()" style="background: none; border: none; color: white; margin-left: 10px; cursor: pointer; font-size: 16px;">Ã—</button>
                </div>
            `;
            document.body.appendChild(notification);

            // 3ç§’åè‡ªåŠ¨æ¶ˆå¤±
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.remove();
                }
            }, 3000);
        }

        // å†å²è®°å½•ç®¡ç†
        function saveToHistory(fileName, url, title, analysisData, supplementData, timestamp = Date.now()) {
            try {
                let history = JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]');

                // æå–ç½‘ç«™åç§°ï¼ˆåŸŸåï¼‰
                let siteName = fileName.replace(/\.(html?|htm)$/i, '');
                if (url && url.startsWith('http')) {
                    try {
                        const urlObj = new URL(url);
                        siteName = urlObj.hostname;
                    } catch (e) {
                        console.warn('URLè§£æå¤±è´¥:', url);
                    }
                }

                console.log('ä¿å­˜å†å²è®°å½• - æ–‡ä»¶å:', fileName, 'ç½‘ç«™å:', siteName);

                const record = {
                    id: timestamp,
                    fileName: fileName,
                    siteName: siteName,
                    title: title || siteName,
                    url: url,
                    timestamp: timestamp,
                    // ä¿å­˜å®Œæ•´çš„åˆ†ææ•°æ®
                    analysisData: analysisData,
                    supplementData: supplementData
                };

                // é¿å…é‡å¤è®°å½•ï¼ˆç›¸åŒç½‘ç«™åç§°ï¼‰
                history = history.filter(item => item.siteName !== siteName);

                // æ·»åŠ åˆ°å¼€å¤´
                history.unshift(record);

                // é™åˆ¶è®°å½•æ•°é‡
                history = history.slice(0, MAX_HISTORY_RECORDS);

                localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
                console.log('å†å²è®°å½•å·²ä¿å­˜:', siteName);

                displayHistory();
            } catch (error) {
                console.warn('ä¿å­˜å†å²è®°å½•å¤±è´¥:', error);
            }
        }

        function loadHistory() {
            try {
                return JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]');
            } catch (error) {
                console.warn('è¯»å–å†å²è®°å½•å¤±è´¥:', error);
                return [];
            }
        }

        function displayHistory() {
            const history = loadHistory();
            const historyCard = document.getElementById('recentHistory');
            const historyList = document.getElementById('historyList');

            if (history.length === 0) {
                historyCard.style.display = 'none';
                return;
            }

            historyCard.style.display = 'block';

            historyList.innerHTML = history.map((record, index) => `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; border-radius: 4px; background: ${index % 2 === 0 ? '#f8f8f8' : '#fff'}; margin-bottom: 2px; cursor: pointer;" onclick="loadHistoryRecord('${record.id}')">
                    <div>
                        <div style="font-weight: 600; color: #644a40; font-size: 13px;">${record.siteName}</div>
                        <div style="font-size: 11px; color: #666; margin-top: 2px;">${new Date(record.timestamp).toLocaleString()}</div>
                    </div>
                    <button onclick="event.stopPropagation(); removeHistoryRecord('${record.id}')" style="background: none; border: none; color: #dc3545; cursor: pointer; font-size: 12px; padding: 2px 4px;">Ã—</button>
                </div>
            `).join('');
        }

        function loadHistoryRecord(recordId) {
            const history = loadHistory();
            const record = history.find(item => item.id.toString() === recordId.toString());

            if (record && record.analysisData) {
                console.log('ä»å†å²è®°å½•æ¢å¤æ•°æ®:', record.siteName);

                // åˆ›å»ºæ–‡ä»¶çŠ¶æ€æŒ‡ç¤ºå™¨
                createFileStatusIndicator(record.fileName);

                // æ¢å¤è¡¥å……ä¿¡æ¯ï¼ˆå¦‚æœæœ‰ï¼‰
                if (record.supplementData) {
                    const supplementInput = document.getElementById('supplementDataInput');
                    if (supplementInput) {
                        supplementInput.value = record.supplementData;
                    }
                }

                // ç›´æ¥æ˜¾ç¤ºåˆ†æç»“æœ
                displayResults(record.analysisData.analysis, record.analysisData.supplementInfo);

                // æ˜¾ç¤ºæ¢å¤æç¤º
                showRestoreNotification(`å·²ä»å†å²è®°å½•æ¢å¤ï¼š${record.siteName}`);
            } else {
                alert(`å†å²è®°å½•æ•°æ®ä¸å®Œæ•´ï¼Œæ— æ³•æ¢å¤åˆ†æç»“æœã€‚`);
            }
        }

        function removeHistoryRecord(recordId) {
            let history = loadHistory();
            history = history.filter(item => item.id.toString() !== recordId.toString());
            localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
            displayHistory();
        }

        function clearHistory() {
            localStorage.removeItem(HISTORY_KEY);
            displayHistory();

            // æ˜¾ç¤ºæ¸…é™¤æç¤º
            const notification = document.createElement('div');
            notification.innerHTML = `
                <div style="position: fixed; top: 20px; right: 20px; background: #dc3545; color: white; padding: 12px 16px; border-radius: 6px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 1000; font-size: 14px;">
                    ğŸ—‘ï¸ å†å²è®°å½•å·²æ¸…ç©º
                    <button onclick="this.parentElement.remove()" style="background: none; border: none; color: white; margin-left: 10px; cursor: pointer; font-size: 16px;">Ã—</button>
                </div>
            `;
            document.body.appendChild(notification);
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.remove();
                }
            }, 3000);
        }

        // å¤åˆ¶æ‰€æœ‰æ•°æ®åˆ°Excel
        function copyToExcel() {
            try {
                // è·å–å½“å‰åˆ†ææ•°æ®
                const savedData = loadFromStorage();
                if (!savedData || !savedData.analysisResults) {
                    alert('æ²¡æœ‰å¯å¤åˆ¶çš„åˆ†ææ•°æ®');
                    return;
                }

                const analysis = savedData.analysisResults.analysis;
                const supplementInfo = savedData.analysisResults.supplementInfo;

                // åˆ›å»ºå•è¡Œæ ¼å¼çš„Excelæ•°æ®
                const headers = [
                    'å…³é”®è¯', 'URL', 'è·å¾—æµé‡', 'æœç´¢ç»“æœæ•°é‡', 'Intitle', 'KDéš¾åº¦', 'KGR',
                    'é¡µé¢æ ‡é¢˜', 'é¡µé¢æè¿°', 'H1', 'H2', 'å•è¯æ•°',
                    '1è¯', '2è¯', '3è¯', '4è¯',
                    'SERPç«äº‰åˆ†ææ ‡é¢˜', 'SERPç«äº‰åˆ†æç½‘å€'
                ];

                const dataRow = [];

                // å…³é”®è¯æŒ‡æ ‡
                if (supplementInfo && supplementInfo.keywordInfo) {
                    const kw = supplementInfo.keywordInfo;
                    dataRow.push(kw.keyword || ''); // å…³é”®è¯
                    dataRow.push(kw.url || ''); // URL
                    dataRow.push(kw.traffic || ''); // è·å¾—æµé‡
                    dataRow.push(kw.results || ''); // æœç´¢ç»“æœæ•°é‡
                    dataRow.push(kw.intitle || ''); // Intitle
                    dataRow.push(kw.difficulty || ''); // KDéš¾åº¦
                    dataRow.push(calculateKGR(kw.intitle, kw.results)); // KGR
                } else {
                    dataRow.push('', '', '', '', '', '', ''); // ç©ºçš„å…³é”®è¯æŒ‡æ ‡
                }

                // é¡µé¢ä¿¡æ¯
                dataRow.push(analysis.title || ''); // é¡µé¢æ ‡é¢˜
                dataRow.push(analysis.description || ''); // é¡µé¢æè¿°

                // Hæ ‡ç­¾
                const h1Tags = analysis.headings?.filter(h => h.level === 1).map(h => h.text).join('; ') || '';
                const h2Tags = analysis.headings?.filter(h => h.level === 2).map(h => h.text).join('; ') || '';
                dataRow.push(h1Tags); // H1
                dataRow.push(h2Tags); // H2

                // å•è¯æ•°
                dataRow.push(analysis.wordCount || '0'); // å•è¯æ•°

                // å…³é”®è¯å¯†åº¦ï¼ˆæŒ‰è¯æ•°åˆ†ç»„ï¼‰
                const keywords1 = analysis.keywords?.single?.map(k => `${k.word}(${k.count})`).join('; ') || '';
                const keywords2 = analysis.keywords?.double?.map(k => `${k.word}(${k.count})`).join('; ') || '';
                const keywords3 = analysis.keywords?.triple?.map(k => `${k.word}(${k.count})`).join('; ') || '';
                const keywords4 = analysis.keywords?.quadruple?.map(k => `${k.word}(${k.count})`).join('; ') || '';

                dataRow.push(keywords1); // 1è¯
                dataRow.push(keywords2); // 2è¯
                dataRow.push(keywords3); // 3è¯
                dataRow.push(keywords4); // 4è¯

                // SERPç«äº‰åˆ†æ
                if (supplementInfo && supplementInfo.serpLinks && supplementInfo.serpLinks.length > 0) {
                    const serpTitles = supplementInfo.serpLinks.map(link => link.title).join('; ');
                    const serpUrls = supplementInfo.serpLinks.map(link => link.url).join('; ');
                    dataRow.push(serpTitles); // SERPç«äº‰åˆ†ææ ‡é¢˜
                    dataRow.push(serpUrls); // SERPç«äº‰åˆ†æç½‘å€
                } else {
                    dataRow.push('', ''); // ç©ºçš„SERPæ•°æ®
                }

                const excelData = [headers, dataRow];

                // è½¬æ¢ä¸ºåˆ¶è¡¨ç¬¦åˆ†éš”çš„æ ¼å¼
                const tsvContent = excelData.map(row => row.join('\t')).join('\n');

                // å¤åˆ¶åˆ°å‰ªè´´æ¿ - ä¼˜å…ˆä½¿ç”¨æ›´å¯é çš„æ–¹æ³•
                try {
                    if (navigator.clipboard && window.isSecureContext) {
                        navigator.clipboard.writeText(tsvContent).then(() => {
                            showCopySuccessNotification();
                        }).catch(err => {
                            console.warn('Clipboard APIå¤±è´¥ï¼Œä½¿ç”¨fallback:', err);
                            fallbackCopyToClipboard(tsvContent);
                        });
                    } else {
                        fallbackCopyToClipboard(tsvContent);
                    }
                } catch (error) {
                    console.error('å¤åˆ¶è¿‡ç¨‹å‡ºé”™:', error);
                    fallbackCopyToClipboard(tsvContent);
                }

            } catch (error) {
                console.error('å¤åˆ¶åˆ°Excelå¤±è´¥:', error);
                alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·é‡è¯•');
            }
        }

        function getStatusText(status) {
            if (!status) return '';
            switch (status) {
                case 'good': return 'è‰¯å¥½';
                case 'warning': return 'è­¦å‘Š';
                case 'error': return 'é”™è¯¯';
                default: return status;
            }
        }

        function calculateKGR(intitle, results) {
            const intitleNum = parseFloat(intitle) || 0;
            const resultsNum = parseFloat(results) || 0;
            if (resultsNum === 0) return 'N/A';
            return (intitleNum / resultsNum).toFixed(4);
        }

        function fallbackCopyToClipboard(text) {
            try {
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.top = '-1000px';
                textArea.style.left = '-1000px';
                textArea.style.width = '1px';
                textArea.style.height = '1px';
                textArea.style.opacity = '0';
                textArea.style.border = 'none';
                textArea.style.outline = 'none';
                textArea.style.boxShadow = 'none';
                textArea.style.background = 'transparent';

                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                textArea.setSelectionRange(0, 99999); // å¯¹ç§»åŠ¨è®¾å¤‡æ›´å¥½çš„æ”¯æŒ

                const successful = document.execCommand('copy');
                document.body.removeChild(textArea);

                if (successful) {
                    showCopySuccessNotification();
                } else {
                    // æ˜¾ç¤ºä¸€ä¸ªæ¨¡æ€æ¡†è®©ç”¨æˆ·æ‰‹åŠ¨å¤åˆ¶
                    showManualCopyDialog(text);
                }
            } catch (err) {
                console.error('Fallbackå¤åˆ¶å¤±è´¥:', err);
                showManualCopyDialog(text);
            }
        }

        function showManualCopyDialog(text) {
            const modal = document.createElement('div');
            modal.innerHTML = `
                <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10000; display: flex; align-items: center; justify-content: center;">
                    <div style="background: white; padding: 20px; border-radius: 8px; max-width: 500px; max-height: 400px; overflow: auto;">
                        <h3 style="margin-top: 0;">æ‰‹åŠ¨å¤åˆ¶æ•°æ®</h3>
                        <p>è¯·æ‰‹åŠ¨é€‰æ‹©ä¸‹é¢çš„æ–‡æœ¬å¹¶å¤åˆ¶ï¼ˆCtrl+Cï¼‰ï¼š</p>
                        <textarea readonly style="width: 100%; height: 200px; font-family: monospace; font-size: 12px; border: 1px solid #ccc; padding: 8px;">${text}</textarea>
                        <div style="text-align: right; margin-top: 10px;">
                            <button onclick="this.closest('div').parentElement.remove()" style="padding: 8px 16px; background: #644a40; color: white; border: none; border-radius: 4px; cursor: pointer;">å…³é—­</button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            // è‡ªåŠ¨é€‰æ‹©æ–‡æœ¬
            const textarea = modal.querySelector('textarea');
            setTimeout(() => {
                textarea.focus();
                textarea.select();
            }, 100);
        }

        function showCopySuccessNotification() {
            const notification = document.createElement('div');
            notification.innerHTML = `
                <div style="position: fixed; top: 20px; right: 20px; background: #28a745; color: white; padding: 12px 16px; border-radius: 6px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 1000; font-size: 14px;">
                    ğŸ“‹ å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼Œå¯ç²˜è´´åˆ°Excel
                    <button onclick="this.parentElement.remove()" style="background: none; border: none; color: white; margin-left: 10px; cursor: pointer; font-size: 16px;">Ã—</button>
                </div>
            `;
            document.body.appendChild(notification);

            setTimeout(() => {
                if (notification.parentElement) {
                    notification.remove();
                }
            }, 4000);
        }

        // é¡µé¢åŠ è½½å®Œæˆåæ‰§è¡Œæ¢å¤
        window.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                restoreDataOnLoad();
                displayHistory();
                initializeFileInput();
            }, 100);
        });

        // å­˜å‚¨ä¸Šä¼ çš„æ–‡ä»¶
        let uploadedFiles = [];

        // åˆå§‹åŒ–æ–‡ä»¶è¾“å…¥ç›‘å¬å™¨
        function initializeFileInput() {
            const fileInput = document.getElementById('fileInput');
            fileInput.addEventListener('change', handleFileSelection);
        }

        // å¤„ç†æ–‡ä»¶é€‰æ‹©
        function handleFileSelection(event) {
            const newFiles = Array.from(event.target.files);

            // æ£€æŸ¥é‡å¤æ–‡ä»¶åï¼Œé¿å…æ·»åŠ ç›¸åŒçš„æ–‡ä»¶
            newFiles.forEach(newFile => {
                const isDuplicate = uploadedFiles.some(existingFile =>
                    existingFile.name === newFile.name && existingFile.size === newFile.size
                );

                if (!isDuplicate) {
                    uploadedFiles.push(newFile);
                }
            });

            // æ¸…ç©ºæ–‡ä»¶è¾“å…¥æ¡†ï¼Œå…è®¸é‡æ–°é€‰æ‹©ç›¸åŒæ–‡ä»¶
            event.target.value = '';

            displayFileList();
        }

        // æ˜¾ç¤ºæ–‡ä»¶åˆ—è¡¨
        function displayFileList() {
            const fileListDiv = document.getElementById('fileList');
            const analyzeAllBtn = document.getElementById('analyzeAllBtn');
            const copyAllBtn = document.getElementById('copyAllBtn');

            if (uploadedFiles.length === 0) {
                fileListDiv.innerHTML = '';
                analyzeAllBtn.style.display = 'none';
                copyAllBtn.style.display = 'none';
                return;
            }

            analyzeAllBtn.style.display = 'inline-block';
            copyAllBtn.style.display = 'none'; // åªæœ‰åˆ†æå®Œæˆåæ‰æ˜¾ç¤º

            fileListDiv.innerHTML = uploadedFiles.map((file, index) => `
                <div class="file-item" style="border: 1px solid #d8d8d8; border-radius: 6px; padding: 12px; margin-bottom: 8px; background: #fcfcfc;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <strong style="color: #644a40; font-size: 14px;">${file.name}</strong>
                        <div style="display: flex; gap: 4px;">
                            <button class="btn" onclick="removeFile(${index})" style="background: #dc3545; font-size: 12px; padding: 4px 8px;">ç§»é™¤</button>
                            <button class="btn" onclick="viewFileDetails(${index})" id="detailBtn-${index}" style="background: #ccc; font-size: 12px; padding: 4px 8px;" disabled>æŸ¥çœ‹è¯¦æƒ…</button>
                        </div>
                    </div>
                    <textarea class="supplement-input" data-file-index="${index}" placeholder="ä¸ºæ­¤æ–‡ä»¶è¾“å…¥è¡¥å……ä¿¡æ¯ï¼ˆå…³é”®è¯ä¿¡æ¯å’ŒSERPé“¾æ¥æ•°æ®ï¼‰..." style="width: 100%; height: 60px; padding: 8px; border: 1px solid #d8d8d8; border-radius: 4px; font-size: 13px; resize: vertical;"></textarea>
                </div>
            `).join('');
        }

        // ç§»é™¤æŒ‡å®šæ–‡ä»¶
        function removeFile(index) {
            if (index >= 0 && index < uploadedFiles.length) {
                uploadedFiles.splice(index, 1);

                // å¦‚æœæœ‰åˆ†æç»“æœï¼Œä¹Ÿè¦ç§»é™¤å¯¹åº”çš„ç»“æœ
                if (allAnalysisResults.length > index) {
                    allAnalysisResults.splice(index, 1);
                }

                displayFileList();
            }
        }

        // å­˜å‚¨æ‰€æœ‰åˆ†æç»“æœ
        let allAnalysisResults = [];

        // æ‰¹é‡åˆ†ææ‰€æœ‰æ–‡ä»¶
        async function analyzeAllFiles() {
            if (uploadedFiles.length === 0) {
                alert('è¯·å…ˆä¸Šä¼ æ–‡ä»¶');
                return;
            }

            allAnalysisResults = [];
            const analyzeAllBtn = document.getElementById('analyzeAllBtn');
            const originalText = analyzeAllBtn.textContent;

            try {
                analyzeAllBtn.textContent = 'åˆ†æä¸­...';
                analyzeAllBtn.disabled = true;

                for (let i = 0; i < uploadedFiles.length; i++) {
                    const file = uploadedFiles[i];
                    const supplementInput = document.querySelector(`textarea[data-file-index="${i}"]`);
                    const supplementData = supplementInput ? supplementInput.value.trim() : '';

                    analyzeAllBtn.textContent = `åˆ†æä¸­... (${i + 1}/${uploadedFiles.length})`;

                    try {
                        // åˆ†æå•ä¸ªæ–‡ä»¶
                        const analysis = await analyzeFileContent(file);

                        // è§£æè¡¥å……ä¿¡æ¯
                        let supplementInfo = null;
                        if (supplementData) {
                            supplementInfo = parseKeywordAndSerpData(supplementData);
                        }

                        allAnalysisResults.push({
                            fileName: file.name,
                            analysis: analysis,
                            supplementInfo: supplementInfo
                        });

                    } catch (error) {
                        console.error(`åˆ†ææ–‡ä»¶ ${file.name} æ—¶å‡ºé”™:`, error);
                        allAnalysisResults.push({
                            fileName: file.name,
                            analysis: null,
                            supplementInfo: null,
                            error: error.message
                        });
                    }
                }

                analyzeAllBtn.textContent = 'åˆ†æå®Œæˆ';
                const copyAllBtn = document.getElementById('copyAllBtn');
                copyAllBtn.style.display = 'inline-block'; // åˆ†æå®Œæˆåæ˜¾ç¤ºå¤åˆ¶æŒ‰é’®

                // å¯ç”¨æ‰€æœ‰è¯¦æƒ…æŒ‰é’®
                for (let i = 0; i < uploadedFiles.length; i++) {
                    const detailBtn = document.getElementById(`detailBtn-${i}`);
                    if (detailBtn) {
                        detailBtn.disabled = false;
                        detailBtn.style.background = '#666';
                    }
                }

                setTimeout(() => {
                    analyzeAllBtn.textContent = originalText;
                    analyzeAllBtn.disabled = false;
                }, 2000);

            } catch (error) {
                console.error('æ‰¹é‡åˆ†æå‡ºé”™:', error);
                analyzeAllBtn.textContent = originalText;
                analyzeAllBtn.disabled = false;
                alert('æ‰¹é‡åˆ†æå‡ºé”™: ' + error.message);
            }
        }

        // åˆ†æå•ä¸ªæ–‡ä»¶å†…å®¹
        async function analyzeFileContent(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const htmlContent = e.target.result;
                        const analysis = analyzePage(htmlContent, file.name);
                        resolve(analysis);
                    } catch (error) {
                        reject(error);
                    }
                };
                reader.onerror = function() {
                    reject(new Error('æ–‡ä»¶è¯»å–å¤±è´¥'));
                };
                reader.readAsText(file);
            });
        }

        // æ‰¹é‡å¤åˆ¶åˆ°Excel
        function copyAllToExcel() {
            if (allAnalysisResults.length === 0) {
                alert('è¯·å…ˆåˆ†ææ–‡ä»¶');
                return;
            }

            try {
                const headers = [
                    'æ–‡ä»¶å', 'å…³é”®è¯', 'URL', 'è·å¾—æµé‡', 'æœç´¢ç»“æœæ•°é‡', 'Intitle', 'KDéš¾åº¦', 'KGR',
                    'é¡µé¢æ ‡é¢˜', 'é¡µé¢æè¿°', 'H1', 'H2', 'å•è¯æ•°',
                    '1è¯', '2è¯', '3è¯', '4è¯',
                    'SERPç«äº‰åˆ†ææ ‡é¢˜', 'SERPç«äº‰åˆ†æç½‘å€'
                ];

                const dataRows = allAnalysisResults.map(result => {
                    if (result.error) {
                        return [result.fileName, 'åˆ†æå¤±è´¥', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''];
                    }

                    const { fileName, analysis, supplementInfo } = result;
                    const dataRow = [];

                    dataRow.push(fileName); // æ–‡ä»¶å

                    // å…³é”®è¯æŒ‡æ ‡
                    if (supplementInfo && supplementInfo.keywordInfo) {
                        const kw = supplementInfo.keywordInfo;
                        dataRow.push(kw.keyword || ''); // å…³é”®è¯
                        dataRow.push(kw.url || ''); // URL
                        dataRow.push(kw.traffic || ''); // è·å¾—æµé‡
                        dataRow.push(kw.results || ''); // æœç´¢ç»“æœæ•°é‡
                        dataRow.push(kw.intitle || ''); // Intitle
                        dataRow.push(kw.difficulty || ''); // KDéš¾åº¦
                        dataRow.push(calculateKGR(kw.intitle, kw.results)); // KGR
                    } else {
                        dataRow.push('', '', '', '', '', '', ''); // ç©ºçš„å…³é”®è¯æŒ‡æ ‡
                    }

                    // é¡µé¢ä¿¡æ¯
                    dataRow.push(analysis.title || ''); // é¡µé¢æ ‡é¢˜
                    dataRow.push(analysis.description || ''); // é¡µé¢æè¿°

                    // Hæ ‡ç­¾
                    const h1Tags = analysis.headings?.filter(h => h.level === 1).map(h => h.text).join('; ') || '';
                    const h2Tags = analysis.headings?.filter(h => h.level === 2).map(h => h.text).join('; ') || '';
                    dataRow.push(h1Tags); // H1
                    dataRow.push(h2Tags); // H2

                    // å•è¯æ•°
                    dataRow.push(analysis.wordCount || '0'); // å•è¯æ•°

                    // å…³é”®è¯å¯†åº¦ï¼ˆæŒ‰è¯æ•°åˆ†ç»„ï¼‰
                    const keywords1 = analysis.keywords?.single?.map(k => `${k.word}(${k.count})`).join('; ') || '';
                    const keywords2 = analysis.keywords?.double?.map(k => `${k.word}(${k.count})`).join('; ') || '';
                    const keywords3 = analysis.keywords?.triple?.map(k => `${k.word}(${k.count})`).join('; ') || '';
                    const keywords4 = analysis.keywords?.quadruple?.map(k => `${k.word}(${k.count})`).join('; ') || '';

                    dataRow.push(keywords1); // 1è¯
                    dataRow.push(keywords2); // 2è¯
                    dataRow.push(keywords3); // 3è¯
                    dataRow.push(keywords4); // 4è¯

                    // SERPç«äº‰åˆ†æ
                    if (supplementInfo && supplementInfo.serpLinks && supplementInfo.serpLinks.length > 0) {
                        const serpTitles = supplementInfo.serpLinks.map(link => link.title).join('; ');
                        const serpUrls = supplementInfo.serpLinks.map(link => link.url).join('; ');
                        dataRow.push(serpTitles); // SERPç«äº‰åˆ†ææ ‡é¢˜
                        dataRow.push(serpUrls); // SERPç«äº‰åˆ†æç½‘å€
                    } else {
                        dataRow.push('', ''); // ç©ºçš„SERPæ•°æ®
                    }

                    return dataRow;
                });

                const excelData = [headers, ...dataRows];

                // è½¬æ¢ä¸ºåˆ¶è¡¨ç¬¦åˆ†éš”çš„æ ¼å¼
                const tsvContent = excelData.map(row => row.join('\t')).join('\n');

                // å¤åˆ¶åˆ°å‰ªè´´æ¿
                if (navigator.clipboard && window.isSecureContext) {
                    navigator.clipboard.writeText(tsvContent).then(() => {
                        showCopySuccessNotification('æ‰¹é‡æ•°æ®å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
                    }).catch(err => {
                        console.warn('Clipboard APIå¤±è´¥ï¼Œä½¿ç”¨fallback:', err);
                        fallbackCopyToClipboard(tsvContent);
                    });
                } else {
                    fallbackCopyToClipboard(tsvContent);
                }

            } catch (error) {
                console.error('æ‰¹é‡å¤åˆ¶åˆ°Excelå¤±è´¥:', error);
                alert('å¤åˆ¶å¤±è´¥ï¼š' + error.message);
            }
        }

        function showCopySuccessNotification(message) {
            // åˆ›å»ºä¸€ä¸ªä¸´æ—¶çš„æˆåŠŸæç¤º
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #28a745;
                color: white;
                padding: 12px 20px;
                border-radius: 6px;
                font-size: 14px;
                z-index: 1000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            `;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 3000);
        }

        // æŸ¥çœ‹å•ä¸ªæ–‡ä»¶çš„è¯¦æƒ…
        function viewFileDetails(fileIndex) {
            if (fileIndex >= uploadedFiles.length) {
                alert('æ–‡ä»¶ç´¢å¼•é”™è¯¯');
                return;
            }

            if (allAnalysisResults.length === 0) {
                alert('è¯·å…ˆç‚¹å‡»"åˆ†æå…¨éƒ¨"è¿›è¡Œåˆ†æ');
                return;
            }

            const result = allAnalysisResults[fileIndex];
            if (!result) {
                alert('è¯¥æ–‡ä»¶çš„åˆ†æç»“æœä¸å­˜åœ¨ï¼Œè¯·é‡æ–°åˆ†æ');
                return;
            }

            if (result.error) {
                alert(`åˆ†ææ–‡ä»¶ ${result.fileName} æ—¶å‡ºé”™: ${result.error}`);
                return;
            }

            // ä¸´æ—¶ä¿å­˜å½“å‰çš„åˆ†æç»“æœï¼Œç„¶åä½¿ç”¨åŸæœ‰çš„æ˜¾ç¤ºé€»è¾‘
            const originalResults = document.getElementById('results');
            const isResultsVisible = originalResults.style.display !== 'none';

            // æ˜¾ç¤ºç»“æœå¹¶ä½¿ç”¨åŸæœ‰çš„ displayResults å‡½æ•°
            displayResults(result.analysis, result.supplementInfo);

            // å¦‚æœåŸæ¥ç»“æœåŒºåŸŸæ˜¯éšè—çš„ï¼Œç°åœ¨ä¸´æ—¶æ˜¾ç¤º
            if (!isResultsVisible) {
                originalResults.style.display = 'block';

                // æ·»åŠ ä¸€ä¸ªä¸´æ—¶çš„è¿”å›æŒ‰é’®
                const backButton = document.createElement('div');
                backButton.id = 'tempBackButton';
                backButton.innerHTML = `
                    <div style="text-align: center; margin: 20px 0; padding: 16px; background: #f0f0f0; border-radius: 8px;">
                        <p style="margin: 0 0 12px 0; color: #666; font-size: 14px;">æ­£åœ¨æŸ¥çœ‹: <strong>${result.fileName}</strong></p>
                        <button onclick="closeTempDetailView()" style="background: #644a40; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px;">è¿”å›æ–‡ä»¶åˆ—è¡¨</button>
                    </div>
                `;
                originalResults.insertBefore(backButton, originalResults.firstChild);
            }
        }

        // å…³é—­ä¸´æ—¶è¯¦æƒ…æŸ¥çœ‹
        function closeTempDetailView() {
            const tempButton = document.getElementById('tempBackButton');
            if (tempButton) {
                tempButton.remove();
            }

            const originalResults = document.getElementById('results');
            originalResults.style.display = 'none';
        }


        // CORSä»£ç†æœåŠ¡åˆ—è¡¨
        const proxyUrls = [
            'https://api.codetabs.com/v1/proxy?quest=',
            'https://thingproxy.freeboard.io/fetch/',
            'https://cors-anywhere.herokuapp.com/',
            'https://crossorigin.me/',
            'https://api.allorigins.win/get?url='
        ];

        async function fetchPageContent(url, timeout = 12000) {
            const encodedUrl = encodeURIComponent(url);

            for (let i = 0; i < proxyUrls.length; i++) {
                try {
                    console.log(`å°è¯•ä½¿ç”¨ä»£ç† ${i + 1}: ${proxyUrls[i]}`);

                    // åˆ›å»ºå¸¦è¶…æ—¶çš„fetchè¯·æ±‚
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), timeout);

                    let proxyUrl, response;

                    if (proxyUrls[i].includes('allorigins')) {
                        proxyUrl = `${proxyUrls[i]}${encodedUrl}`;
                        response = await fetch(proxyUrl, { signal: controller.signal });
                        clearTimeout(timeoutId);

                        if (response.ok) {
                            const data = await response.json();
                            return {
                                text: () => Promise.resolve(data.contents),
                                ok: true,
                                status: 200
                            };
                        }
                    } else if (proxyUrls[i].includes('codetabs')) {
                        proxyUrl = `${proxyUrls[i]}${encodedUrl}`;
                        response = await fetch(proxyUrl, { signal: controller.signal });
                        clearTimeout(timeoutId);

                        if (response.ok) {
                            return response;
                        }
                    } else if (proxyUrls[i].includes('thingproxy')) {
                        proxyUrl = `${proxyUrls[i]}${url}`;  // thingproxyä¸éœ€è¦ç¼–ç 
                        response = await fetch(proxyUrl, { signal: controller.signal });
                        clearTimeout(timeoutId);

                        if (response.ok) {
                            return response;
                        }
                    } else if (proxyUrls[i].includes('cors-anywhere')) {
                        proxyUrl = `${proxyUrls[i]}${url}`;  // cors-anywhereä¸éœ€è¦ç¼–ç 
                        response = await fetch(proxyUrl, {
                            signal: controller.signal,
                            headers: {
                                'X-Requested-With': 'XMLHttpRequest'
                            }
                        });
                        clearTimeout(timeoutId);

                        if (response.ok) {
                            return response;
                        }
                    } else if (proxyUrls[i].includes('crossorigin')) {
                        proxyUrl = `${proxyUrls[i]}${url}`;  // crossorigin.meä¸éœ€è¦ç¼–ç 
                        response = await fetch(proxyUrl, { signal: controller.signal });
                        clearTimeout(timeoutId);

                        if (response.ok) {
                            return response;
                        }
                    } else {
                        // å…¶ä»–ä»£ç†
                        proxyUrl = `${proxyUrls[i]}${encodedUrl}`;
                        response = await fetch(proxyUrl, { signal: controller.signal });
                        clearTimeout(timeoutId);

                        if (response.ok) {
                            return response;
                        }
                    }
                } catch (error) {
                    console.warn(`ä»£ç† ${i + 1} å¤±è´¥:`, error.name === 'AbortError' ? 'è¶…æ—¶' : error.message);
                    if (i === proxyUrls.length - 1) {
                        throw new Error(`æ‰€æœ‰ä»£ç†éƒ½å¤±è´¥äº†ã€‚æœ€åä¸€ä¸ªé”™è¯¯: ${error.message}`);
                    }
                }
            }
        }

        async function batchDownloadSerpUrls() {
            if (!globalSerpLinks || globalSerpLinks.length === 0) {
                showError('æ²¡æœ‰å¯ä¸‹è½½çš„SERPé“¾æ¥');
                return;
            }

            const progressDiv = document.getElementById('serpProgress');
            progressDiv.style.display = 'block';

            const progressFill = document.getElementById('serpProgressFill');
            const progressText = document.getElementById('serpProgressText');
            const progressCount = document.getElementById('serpProgressCount');
            const progressDetails = document.getElementById('serpProgressDetails');

            let completed = 0;
            let successful = 0;
            const urls = globalSerpLinks.map(link => link.url);

            progressCount.textContent = `0/${urls.length}`;
            progressDetails.innerHTML = '';

            try {
                progressText.textContent = `å¼€å§‹å¹¶å‘ä¸‹è½½ ${urls.length} ä¸ªé“¾æ¥...`;

                // åˆ›å»ºæ‰€æœ‰ä¸‹è½½ä»»åŠ¡
                const downloadTasks = urls.map(async (url, i) => {
                    try {
                        const response = await fetchPageContent(url, 12000); // 12ç§’è¶…æ—¶
                        const html = await response.text();

                        const urlObj = new URL(url);
                        const filename = `${urlObj.hostname}.html`;

                        downloadHTML(html, filename);
                        return { url, status: 'success', filename };
                    } catch (error) {
                        console.error(`ä¸‹è½½å¤±è´¥ ${url}:`, error);
                        return { url, status: 'failed', error: error.message };
                    }
                });

                // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆï¼Œå¹¶å®æ—¶æ›´æ–°è¿›åº¦
                const results = [];
                for (let taskIndex = 0; taskIndex < downloadTasks.length; taskIndex++) {
                    const task = downloadTasks[taskIndex];
                    const result = await task;
                    results.push(result);
                    completed++;

                    if (result.status === 'success') {
                        successful++;
                        progressDetails.innerHTML += `<div style="color: #644a40;">âœ“ ${result.url}</div>`;

                        // åœ¨SERPè¡¨æ ¼ä¸­æ·»åŠ âœ“æ ‡è®°
                        const statusElement = document.getElementById(`download-status-${taskIndex}`);
                        if (statusElement) {
                            statusElement.textContent = 'âœ“';
                            statusElement.title = 'å·²ä¸‹è½½';
                        }
                    } else {
                        progressDetails.innerHTML += `<div style="color: #e54d2e;">âœ— ${result.url} (${result.error})</div>`;

                        // åœ¨SERPè¡¨æ ¼ä¸­æ·»åŠ âœ—æ ‡è®°
                        const statusElement = document.getElementById(`download-status-${taskIndex}`);
                        if (statusElement) {
                            statusElement.textContent = 'âœ—';
                            statusElement.style.color = '#dc3545';
                            statusElement.title = 'ä¸‹è½½å¤±è´¥';
                        }
                    }

                    progressCount.textContent = `${completed}/${urls.length}`;
                    progressFill.style.width = `${(completed / urls.length) * 100}%`;
                    progressText.textContent = `å·²å®Œæˆ: ${completed}/${urls.length}`;
                }

                progressText.textContent = `SERPé“¾æ¥ä¸‹è½½å®Œæˆï¼æˆåŠŸ: ${successful}ä¸ª`;

                // æ’­æ”¾å®Œæˆå£°éŸ³å¹¶éšè—è¿›åº¦æ¡
                setTimeout(() => {
                    progressDiv.style.display = 'none';
                }, 2000);

            } catch (error) {
                showError('SERPé“¾æ¥æ‰¹é‡ä¸‹è½½å¤±è´¥: ' + error.message);
            }
        }

        function copyAllUrls() {
            if (globalSerpLinks.length === 0) {
                return;
            }

            const urls = globalSerpLinks.map(link => link.url).join('\n');

            // ä½¿ç”¨Clipboard APIå¤åˆ¶åˆ°å‰ªè´´æ¿
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(urls).catch(err => {
                    console.error('å¤åˆ¶å¤±è´¥:', err);
                    fallbackCopyTextToClipboard(urls);
                });
            } else {
                // å¤‡ç”¨æ–¹æ¡ˆ
                fallbackCopyTextToClipboard(urls);
            }
        }

        function fallbackCopyTextToClipboard(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.top = '0';
            textArea.style.left = '0';
            textArea.style.position = 'fixed';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();

            try {
                document.execCommand('copy');
            } catch (err) {
                console.error('å¤åˆ¶å¤±è´¥:', err);
            }

            document.body.removeChild(textArea);
        }

    </script>
</body>
</html>