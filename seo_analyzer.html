<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SEOé¡µé¢åˆ†æå·¥å…·</title>
    <meta name="description" content="ç®€æ´çš„SEOé¡µé¢åˆ†æå·¥å…·ï¼Œæ£€æµ‹ç½‘é¡µTitleã€Descriptionã€Hæ ‡ç­¾ã€å…³é”®è¯å¯†åº¦ç­‰">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f9f9f9;
            color: #202020;
            line-height: 1.5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .header h1 {
            font-size: 2.5em;
            font-weight: 700;
            color: #644a40;
            margin-bottom: 8px;
        }

        .header p {
            font-size: 1.1em;
            color: #646464;
        }

        .card {
            background: #fcfcfc;
            border: 1px solid #d8d8d8;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 16px;
        }

        .input-group {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
        }

        .input-group input,
        .input-group textarea {
            flex: 1;
            padding: 12px;
            border: 1px solid #d8d8d8;
            border-radius: 6px;
            font-size: 14px;
            background: #fcfcfc;
            color: #202020;
        }

        .input-group input:focus,
        .input-group textarea:focus {
            outline: none;
            border-color: #644a40;
            box-shadow: 0 0 0 2px rgba(100, 74, 64, 0.1);
        }

        .btn {
            padding: 12px 24px;
            background: #644a40;
            color: #ffffff;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .btn:hover {
            background: #66493e;
        }

        .btn:disabled {
            background: #efefef;
            color: #646464;
            cursor: not-allowed;
        }

        .loading {
            display: none;
            text-align: center;
            margin: 20px 0;
            color: #646464;
        }

        .error {
            background: #e54d2e;
            color: #ffffff;
            padding: 12px;
            border-radius: 6px;
            margin: 16px 0;
            display: none;
        }

        .section-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #644a40;
            margin-bottom: 12px;
            padding-bottom: 6px;
            border-bottom: 1px solid #d8d8d8;
        }

        .meta-grid {
            display: grid;
            gap: 16px;
        }

        .meta-item {
            background: #efefef;
            padding: 16px;
            border-radius: 6px;
        }

        .meta-label {
            font-weight: 600;
            color: #644a40;
            margin-bottom: 4px;
            font-size: 14px;
        }

        .meta-value {
            color: #202020;
            word-break: break-word;
            font-size: 14px;
        }

        .status {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 8px;
        }

        .status.good {
            background: #ffdfb5;
            color: #582d1d;
        }

        .status.warning {
            background: #ffe6c4;
            color: #582d1d;
        }

        .status.error {
            background: #e54d2e;
            color: #ffffff;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 16px;
        }

        .stat-card {
            background: #efefef;
            padding: 20px;
            border-radius: 6px;
            text-align: center;
        }

        .stat-number {
            font-size: 2em;
            font-weight: 700;
            color: #644a40;
            margin-bottom: 4px;
        }

        .stat-label {
            font-size: 12px;
            color: #646464;
            font-weight: 500;
        }

        .heading-item {
            padding: 6px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
            border-left: 2px solid #644a40;
        }

        .heading-item.h1 {
            margin-left: 0;
            font-weight: normal;
        }

        .heading-item.h2 {
            margin-left: 24px;
            font-weight: normal;
        }

        .heading-level {
            background: #644a40;
            color: #ffffff;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            min-width: 24px;
            text-align: center;
        }

        .heading-text {
            color: #202020;
            line-height: 1.4;
            font-size: 14px;
            font-weight: normal;
        }

        .keyword-categories {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 16px;
        }

        .keyword-category {
            border: 1px solid #d8d8d8;
            border-radius: 6px;
            overflow: hidden;
        }

        .keyword-category-header {
            background: #efefef;
            padding: 12px 16px;
            font-weight: 600;
            color: #644a40;
            border-bottom: 1px solid #d8d8d8;
        }

        .keyword-list {
            padding: 12px;
        }

        .keyword-item {
            padding: 6px 0;
            border-bottom: 1px solid #e8e8e8;
        }

        .keyword-item:last-child {
            border-bottom: none;
        }

        .keyword-text {
            font-weight: 500;
            color: #202020;
            margin-bottom: 4px;
        }

        .keyword-count {
            background: #ffdfb5;
            color: #582d1d;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 12px;
            display: inline-block;
        }


        .batch-textarea {
            width: 100%;
            height: 100px;
            padding: 12px;
            border: 1px solid #d8d8d8;
            border-radius: 6px;
            resize: vertical;
            font-family: monospace;
            font-size: 13px;
            margin-bottom: 12px;
        }

        .progress-section {
            background: #e8e8e8;
            border-radius: 6px;
            padding: 16px;
            margin-top: 16px;
            display: none;
        }

        .progress-bar {
            background: #d8d8d8;
            height: 6px;
            border-radius: 3px;
            overflow: hidden;
            margin: 8px 0;
        }

        .progress-fill {
            background: #644a40;
            height: 100%;
            width: 0%;
            transition: width 0.3s;
        }

        .progress-details {
            font-size: 12px;
            color: #646464;
            margin-top: 8px;
        }

        .no-data {
            text-align: center;
            color: #646464;
            padding: 40px;
            font-style: italic;
        }

        .supplement-section {
            margin-top: 16px;
        }

        .supplement-section h3 {
            color: #644a40;
            margin-bottom: 12px;
            font-size: 1.1em;
        }

        .serp-table {
            width: 100%;
            border-collapse: collapse;
            background: #fcfcfc;
            border: 1px solid #d8d8d8;
            border-radius: 6px;
            overflow: hidden;
        }

        .serp-table th {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #d8d8d8;
            color: #644a40;
            font-weight: 600;
            background: #efefef;
            font-size: 14px;
        }

        .serp-table td {
            padding: 8px;
            border-bottom: 1px solid #e8e8e8;
            vertical-align: top;
            font-size: 14px;
            line-height: 1.3;
        }

        .serp-table tr:last-child td {
            border-bottom: none;
        }

        .results {
            display: none;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px 16px;
            }

            .input-group {
                flex-direction: column;
            }

            .header h1 {
                font-size: 2em;
            }

            .card > div[style*="grid-template-columns"] {
                grid-template-columns: 1fr !important;
                gap: 12px !important;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>SEOé¡µé¢åˆ†æå·¥å…·</h1>
            <p>åˆ†æHTMLæ–‡ä»¶SEOè¦ç´ ï¼šTitleã€Descriptionã€Hæ ‡ç­¾ã€å…³é”®è¯å¯†åº¦</p>
        </div>

        <div class="card">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px;">
                <!-- æ‰¹é‡ä¸‹è½½åŒºåŸŸ -->
                <div>
                    <h3 style="margin-bottom: 12px; color: #644a40;">æ‰¹é‡ä¸‹è½½HTML</h3>
                    <textarea id="batchUrls" class="batch-textarea" placeholder="æ¯è¡Œä¸€ä¸ªURLï¼š&#10;https://www.example1.com&#10;https://www.example2.com" style="height: 112px; margin-bottom: 8px;"></textarea>
                    <button class="btn" onclick="batchDownload()" id="batchBtn">æ‰¹é‡ä¸‹è½½</button>
                </div>

                <!-- æ–‡ä»¶åˆ†æåŒºåŸŸ -->
                <div>
                    <h3 style="margin-bottom: 12px; color: #644a40;">åˆ†æHTMLæ–‡ä»¶</h3>
                    <input type="file" id="fileInput" accept=".html,.htm" style="width: 100%; padding: 12px; border: 1px solid #d8d8d8; border-radius: 6px; font-size: 14px; background: #fcfcfc; color: #202020; margin-bottom: 8px;">
                    <textarea id="supplementDataInput" class="batch-textarea" placeholder="å¯ç²˜è´´å…³é”®è¯ä¿¡æ¯å’ŒSERPé“¾æ¥æ•°æ®ï¼Œåœ¨åˆ†æHTMLæ–‡ä»¶æ—¶ä¸€åŒå¤„ç†..." style="height: 60px; margin-bottom: 8px;"></textarea>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn" onclick="analyzeFile()">åˆ†æç½‘ç«™</button>
                        <button class="btn" onclick="testParseData()" style="background: #666; font-size: 12px; padding: 8px 12px;">æµ‹è¯•è§£æ</button>
                    </div>
                </div>
            </div>

            <div id="batchProgress" class="progress-section">
                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                    <span id="progressText">å‡†å¤‡ä¸‹è½½...</span>
                    <span id="progressCount">0/0</span>
                </div>
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill"></div>
                </div>
                <div id="progressDetails" class="progress-details"></div>
            </div>
        </div>

        <div class="loading">
            <p>æ­£åœ¨åˆ†æ...</p>
        </div>

        <div class="error" id="errorMessage"></div>

        <div class="results" id="results">
            <!-- é¡µé¢ä¿¡æ¯å’Œæ ‡é¢˜ç»“æ„å¹¶åˆ— -->
            <div class="card">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px;">
                    <div>
                        <div class="meta-grid" id="basicInfo"></div>

                        <!-- å…³é”®è¯æŒ‡æ ‡åŒºåŸŸ -->
                        <div id="keywordMetrics" style="margin-top: 20px;"></div>
                    </div>
                    <div>
                        <!-- é¡µé¢åŸºæœ¬ä¿¡æ¯æ”¾åœ¨æ ‡é¢˜ç»“æ„ä¸Šé¢ -->
                        <div id="titleDescriptionInfo" style="margin-bottom: 20px;"></div>

                        <div id="headingsInfo"></div>
                    </div>
                </div>
            </div>

            <div class="card">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                    <h2 class="section-title" style="margin-bottom: 0;">å…³é”®è¯å¯†åº¦</h2>
                    <div style="color: #646464; font-size: 14px;">å•è¯æ•°ï¼š<span style="font-weight: 600; color: #644a40;" id="wordCountDisplay">0</span></div>
                </div>
                <div class="keyword-categories" id="keywordsInfo"></div>
            </div>

            <div id="supplementCard" class="card" style="display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                    <h2 class="section-title" style="margin-bottom: 0;">SERPç«äº‰åˆ†æ</h2>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn" onclick="copyAllUrls()" style="background: #666; font-size: 12px; padding: 6px 12px;">å¤åˆ¶æ‰€æœ‰ç½‘å€</button>
                        <button class="btn" onclick="batchDownloadSerpUrls()" style="background: #644a40; font-size: 12px; padding: 6px 12px;">æ‰¹é‡ä¸‹è½½HTML</button>
                    </div>
                </div>
                <div id="supplementInfo"></div>
            </div>
        </div>
    </div>

    <script>
        async function analyzeFile() {
            const fileInput = document.getElementById('fileInput');

            if (!fileInput.files || fileInput.files.length === 0) {
                showError('è¯·é€‰æ‹©HTMLæ–‡ä»¶');
                return;
            }

            const file = fileInput.files[0];

            if (!file.name.toLowerCase().endsWith('.html') && !file.name.toLowerCase().endsWith('.htm')) {
                showError('è¯·é€‰æ‹©HTMLæ–‡ä»¶');
                return;
            }

            showLoading(true);

            try {
                const html = await file.text();
                const analysis = analyzePage(html, file.name);

                // æ£€æŸ¥æ˜¯å¦æœ‰è¡¥å……ä¿¡æ¯
                const supplementData = document.getElementById('supplementDataInput').value.trim();
                let supplementInfo = null;
                if (supplementData) {
                    try {
                        supplementInfo = parseKeywordAndSerpData(supplementData);
                    } catch (error) {
                        console.warn('è¡¥å……ä¿¡æ¯è§£æå¤±è´¥', error);
                    }
                }

                displayResults(analysis, supplementInfo);
            } catch (error) {
                showError('æ–‡ä»¶è¯»å–å¤±è´¥');
            } finally {
                showLoading(false);
            }
        }



        function analyzePage(html, url) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');

            const analysis = {
                url: url,
                title: '',
                description: '',
                h1: [],
                headings: [],
                wordCount: 0,
                charCount: 0,
                keywords: {},
                images: 0,
                links: 0
            };

            // åŸºç¡€ä¿¡æ¯
            const titleEl = doc.querySelector('title');
            analysis.title = titleEl ? titleEl.textContent.trim() : '';

            const descEl = doc.querySelector('meta[name="description"]');
            analysis.description = descEl ? descEl.getAttribute('content').trim() : '';

            const h1Elements = doc.querySelectorAll('h1');
            analysis.h1 = Array.from(h1Elements).map(el => el.textContent.trim()).filter(text => text);

            // æ ‡é¢˜ç»“æ„ (H1-H2æ ‡ç­¾æŒ‰é¡µé¢å‡ºç°é¡ºåºå±•ç¤º)
            const allHeadings = doc.querySelectorAll('h1, h2');
            analysis.headings = Array.from(allHeadings).map(heading => {
                const level = parseInt(heading.tagName.substring(1));
                const text = heading.textContent.trim();
                return { level, text };
            }).filter(heading => heading.text);

            // æ–‡æœ¬åˆ†æ - åªåˆ†æå¯è§æ–‡æœ¬å†…å®¹ï¼Œæ’é™¤è„šæœ¬å’Œæ ·å¼
            let visibleText = '';

            // è·å–æ‰€æœ‰å¯è§çš„æ–‡æœ¬èŠ‚ç‚¹
            const getVisibleText = (element) => {
                let text = '';

                if (!element) return text;

                // è·³è¿‡ä¸å¯è§å…ƒç´ 
                const tagName = element.tagName ? element.tagName.toLowerCase() : '';
                if (['script', 'style', 'noscript', 'meta', 'link', 'head'].includes(tagName)) {
                    return text;
                }

                // å¦‚æœæ˜¯æ–‡æœ¬èŠ‚ç‚¹
                if (element.nodeType === Node.TEXT_NODE) {
                    return element.textContent.trim();
                }

                // é€’å½’å¤„ç†å­èŠ‚ç‚¹
                for (const child of element.childNodes) {
                    text += ' ' + getVisibleText(child);
                }

                return text;
            };

            visibleText = getVisibleText(doc.body || doc);
            const cleanText = visibleText.replace(/\s+/g, ' ').trim();

            analysis.wordCount = cleanText ? cleanText.split(' ').filter(word => word.length > 0).length : 0;
            analysis.charCount = cleanText.length;

            // å…³é”®è¯åˆ†æ - åªåˆ†æå¯è§æ–‡æœ¬å†…å®¹
            if (cleanText) {
                const words = cleanText.toLowerCase()
                    .replace(/[^\w\s\u4e00-\u9fff]/g, ' ')
                    .split(/\s+/)
                    .filter(word => word.length >= 2);

                // å•è¯
                const singleWords = {};
                words.forEach(word => {
                    singleWords[word] = (singleWords[word] || 0) + 1;
                });

                // 2è¯ç»„åˆ
                const twoWordPhrases = {};
                for (let i = 0; i < words.length - 1; i++) {
                    const phrase = `${words[i]} ${words[i + 1]}`;
                    twoWordPhrases[phrase] = (twoWordPhrases[phrase] || 0) + 1;
                }

                // 3è¯ç»„åˆ
                const threeWordPhrases = {};
                for (let i = 0; i < words.length - 2; i++) {
                    const phrase = `${words[i]} ${words[i + 1]} ${words[i + 2]}`;
                    threeWordPhrases[phrase] = (threeWordPhrases[phrase] || 0) + 1;
                }

                // 4è¯ç»„åˆ
                const fourWordPhrases = {};
                for (let i = 0; i < words.length - 3; i++) {
                    const phrase = `${words[i]} ${words[i + 1]} ${words[i + 2]} ${words[i + 3]}`;
                    fourWordPhrases[phrase] = (fourWordPhrases[phrase] || 0) + 1;
                }


                const processKeywords = (wordFreq, totalCount, limit = 5) => {
                    return Object.entries(wordFreq)
                        .filter(([word, count]) => count > 1)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, limit)
                        .map(([word, count]) => ({
                            word,
                            count,
                            density: ((count / totalCount) * 100).toFixed(2)
                        }));
                };

                analysis.keywords = {
                    single: processKeywords(singleWords, words.length, 5),
                    double: processKeywords(twoWordPhrases, words.length - 1, 5),
                    triple: processKeywords(threeWordPhrases, words.length - 2, 5),
                    quadruple: processKeywords(fourWordPhrases, words.length - 3, 5)
                };
            }

            analysis.images = doc.querySelectorAll('img').length;
            analysis.links = doc.querySelectorAll('a').length;

            return analysis;
        }

        function displayResults(analysis, supplementInfo = null) {
            // åŸºç¡€ä¿¡æ¯å’Œå…³é”®è¯ä¿¡æ¯
            const basicInfoDiv = document.getElementById('basicInfo');
            let basicInfoHTML = '';

            // å¦‚æœæœ‰å…³é”®è¯ä¿¡æ¯ï¼Œå…ˆæ˜¾ç¤ºå…³é”®è¯å’ŒURL
            if (supplementInfo && supplementInfo.keywordInfo) {
                const kw = supplementInfo.keywordInfo;
                basicInfoHTML += `
                    <div class="meta-item">
                        <div class="meta-label">å…³é”®è¯ï¼š<span style="font-weight: normal; color: #202020; margin-left: 8px;">${kw.keyword}</span></div>
                    </div>
                    <div class="meta-item">
                        <div class="meta-label">URLï¼š<span style="font-weight: normal; margin-left: 8px;"><a href="${kw.url}" target="_blank" style="color: #644a40; text-decoration: underline; word-break: break-all; font-size: 12px;">${kw.url}</a></span></div>
                    </div>
                `;

                // åªåœ¨æœç´¢é‡ä¸ä¸º0æ—¶æ˜¾ç¤º
                if (kw.searchVolume && parseInt(kw.searchVolume) > 0) {
                    basicInfoHTML += `
                        <div class="meta-item">
                            <div class="meta-label">æœç´¢é‡ï¼š<span style="font-weight: normal; color: #202020; margin-left: 8px;">${parseInt(kw.searchVolume).toLocaleString()}</span></div>
                        </div>
                    `;
                }

                basicInfoHTML += `
                    <div class="meta-item">
                        <div class="meta-label">è·å¾—æµé‡ï¼š<span style="font-weight: normal; color: #202020; margin-left: 8px;">${kw.traffic}</span></div>
                    </div>
                `;
            }

            basicInfoDiv.innerHTML = basicInfoHTML;


            // æ ‡é¢˜ç»“æ„ (æ–‡ç« å¤§çº²é£æ ¼)
            const headingsDiv = document.getElementById('headingsInfo');
            if (analysis.headings.length > 0) {
                headingsDiv.innerHTML = analysis.headings.map(heading => `
                    <div class="heading-item h${heading.level}">
                        <span class="heading-level">H${heading.level}</span>
                        <span class="heading-text">${heading.text}</span>
                    </div>
                `).join('');
            } else {
                headingsDiv.innerHTML = '<div class="no-data">æœªæ‰¾åˆ°æ ‡é¢˜æ ‡ç­¾</div>';
            }

            // å…³é”®è¯å¯†åº¦
            const keywordsDiv = document.getElementById('keywordsInfo');
            if (analysis.keywords && Object.values(analysis.keywords).some(arr => arr.length > 0)) {
                const generateKeywordCategory = (keywords, title) => {
                    if (keywords.length === 0) {
                        return `
                            <div class="keyword-category">
                                <div class="keyword-category-header">${title}</div>
                                <div class="no-data">æš‚æ— æ•°æ®</div>
                            </div>
                        `;
                    }
                    
                    const keywordItems = keywords.map(keyword => `
                        <div class="keyword-item">
                            <div class="keyword-text">${keyword.word}</div>
                            <span class="keyword-count">${keyword.count}æ¬¡</span>
                        </div>
                    `).join('');

                    return `
                        <div class="keyword-category">
                            <div class="keyword-category-header">${title}</div>
                            <div class="keyword-list">${keywordItems}</div>
                        </div>
                    `;
                };

                keywordsDiv.innerHTML = `
                    ${generateKeywordCategory(analysis.keywords.single, '1è¯')}
                    ${generateKeywordCategory(analysis.keywords.double, '2è¯')}
                    ${generateKeywordCategory(analysis.keywords.triple, '3è¯')}
                    ${generateKeywordCategory(analysis.keywords.quadruple, '4è¯')}
                `;
            } else {
                keywordsDiv.innerHTML = '<div class="no-data">æœªæ‰¾åˆ°å…³é”®è¯æ•°æ®</div>';
            }

            // æ˜¾ç¤ºé¡µé¢æ ‡é¢˜å’Œæè¿°
            const titleDescDiv = document.getElementById('titleDescriptionInfo');
            titleDescDiv.innerHTML = `
                <div class="meta-item" style="margin-bottom: 8px;">
                    <div class="meta-label">é¡µé¢æ ‡é¢˜${getStatusBadge(analysis.title, 'title')}</div>
                    <div class="meta-value">${analysis.title || 'æœªæ‰¾åˆ°'}</div>
                </div>
                <div class="meta-item">
                    <div class="meta-label">é¡µé¢æè¿°${getStatusBadge(analysis.description, 'description')}</div>
                    <div class="meta-value">${analysis.description || 'æœªæ‰¾åˆ°'}</div>
                </div>
            `;

            // æ˜¾ç¤ºå…³é”®è¯æŒ‡æ ‡
            const keywordMetricsDiv = document.getElementById('keywordMetrics');
            if (supplementInfo && supplementInfo.keywordInfo) {
                displayKeywordMetrics(supplementInfo.keywordInfo, keywordMetricsDiv);
            } else {
                keywordMetricsDiv.innerHTML = '';
            }

            // æ˜¾ç¤ºè¡¥å……ä¿¡æ¯
            const supplementCard = document.getElementById('supplementCard');
            const supplementDiv = document.getElementById('supplementInfo');
            if (supplementInfo && supplementInfo.serpLinks && supplementInfo.serpLinks.length > 0) {
                displaySupplementInfo(supplementInfo, supplementDiv);
                supplementCard.style.display = 'block';
            } else {
                supplementCard.style.display = 'none';
            }

            // æ›´æ–°å•è¯æ•°æ˜¾ç¤º
            const wordCountDisplay = document.getElementById('wordCountDisplay');
            if (wordCountDisplay) {
                wordCountDisplay.textContent = analysis.wordCount;
            }

            document.getElementById('results').style.display = 'block';
        }

        function getStatusBadge(value, type) {
            switch (type) {
                case 'title':
                    if (!value) return '<span class="status error">ç¼ºå¤±</span>';
                    if (value.length < 30) return '<span class="status warning">åçŸ­</span>';
                    if (value.length > 60) return '<span class="status warning">åé•¿</span>';
                    return '<span class="status good">è‰¯å¥½</span>';
                
                case 'description':
                    if (!value) return '<span class="status error">ç¼ºå¤±</span>';
                    if (value.length < 120) return '<span class="status warning">åçŸ­</span>';
                    if (value.length > 160) return '<span class="status warning">åé•¿</span>';
                    return '<span class="status good">è‰¯å¥½</span>';
                
                case 'h1':
                    if (!value || value.length === 0) return '<span class="status error">ç¼ºå¤±</span>';
                    if (value.length > 1) return '<span class="status warning">å¤šä¸ªH1</span>';
                    return '<span class="status good">è‰¯å¥½</span>';
                
                default:
                    return '';
            }
        }

        async function batchDownload() {
            const textarea = document.getElementById('batchUrls');
            const progressDiv = document.getElementById('batchProgress');
            const batchBtn = document.getElementById('batchBtn');
            const autoAnalyze = document.getElementById('autoAnalyze').checked;
            
            const urls = textarea.value
                .split('\n')
                .map(url => url.trim())
                .filter(url => url && url.startsWith('http'));

            if (urls.length === 0) {
                showError('è¯·è¾“å…¥æœ‰æ•ˆçš„ç½‘å€åˆ—è¡¨');
                return;
            }

            progressDiv.style.display = 'block';
            batchBtn.disabled = true;
            batchBtn.textContent = 'ä¸‹è½½ä¸­...';

            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            const progressCount = document.getElementById('progressCount');
            const progressDetails = document.getElementById('progressDetails');

            let completed = 0;
            let successful = 0;
            const results = [];

            progressCount.textContent = `0/${urls.length}`;
            progressDetails.innerHTML = '';

            try {
                for (let i = 0; i < urls.length; i++) {
                    const url = urls[i];
                    progressText.textContent = `æ­£åœ¨ä¸‹è½½: ${url}`;
                    
                    try {
                        const response = await fetchPageContent(url);
                        const html = await response.text();
                        
                        const urlObj = new URL(url);
                        const filename = `${urlObj.hostname}_${Date.now()}_${i + 1}.html`;
                        
                        downloadHTML(html, filename);
                        
                        successful++;
                        results.push({ url, status: 'success', filename, html });
                        
                        progressDetails.innerHTML += `<div style="color: #644a40;">âœ“ ${url}</div>`;
                        
                    } catch (error) {
                        results.push({ url, status: 'failed', error: error.message });
                        progressDetails.innerHTML += `<div style="color: #e54d2e;">âœ— ${url}</div>`;
                    }
                    
                    completed++;
                    progressCount.textContent = `${completed}/${urls.length}`;
                    progressFill.style.width = `${(completed / urls.length) * 100}%`;
                    
                    if (i < urls.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                }
                
                progressText.textContent = `ä¸‹è½½å®Œæˆï¼æˆåŠŸ: ${successful}ä¸ª`;
                
                // æ‰¹é‡ä¸‹è½½åè‡ªåŠ¨åˆ†æç¬¬ä¸€ä¸ªæˆåŠŸçš„æ–‡ä»¶
                if (results.length > 0) {
                    const successResult = results.find(r => r.status === 'success');
                    if (successResult) {
                        setTimeout(() => {
                            const analysis = analyzePage(successResult.html, successResult.url);

                            // æ£€æŸ¥æ˜¯å¦æœ‰è¡¥å……ä¿¡æ¯
                            const supplementData = document.getElementById('supplementDataInput').value.trim();
                            let supplementInfo = null;
                            if (supplementData) {
                                try {
                                    supplementInfo = parseKeywordAndSerpData(supplementData);
                                } catch (error) {
                                    console.warn('è¡¥å……ä¿¡æ¯è§£æå¤±è´¥', error);
                                }
                            }

                            displayResults(analysis, supplementInfo);
                        }, 1000);
                    }
                }
                
            } catch (error) {
                showError('æ‰¹é‡ä¸‹è½½å¤±è´¥: ' + error.message);
            } finally {
                batchBtn.disabled = false;
                batchBtn.textContent = 'æ‰¹é‡ä¸‹è½½';
            }
        }

        function downloadHTML(htmlContent, filename) {
            const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function showLoading(show) {
            document.querySelector('.loading').style.display = show ? 'block' : 'none';
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 5000);
        }

        function parseSupplementData() {
            const textarea = document.getElementById('supplementData');
            const supplementInfo = document.getElementById('supplementInfo');
            const data = textarea.value.trim();

            if (!data) {
                showError('è¯·è¾“å…¥è¡¥å……æ•°æ®');
                return;
            }

            try {
                const result = parseKeywordAndSerpData(data);
                displaySupplementInfo(result);
                supplementInfo.style.display = 'block';
            } catch (error) {
                showError('æ•°æ®è§£æå¤±è´¥ï¼Œè¯·æ£€æŸ¥æ•°æ®æ ¼å¼');
            }
        }

        function parseKeywordAndSerpData(data) {
            console.log('Raw input data:', data);
            const lines = data.split('\n').filter(line => line.trim());
            const result = {
                keywordInfo: null,
                serpLinks: []
            };

            let currentSection = '';
            let keywordHeaderFound = false;
            let serpLinksStarted = false;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                console.log(`Line ${i}: "${line}"`);

                // æ£€æŸ¥æ˜¯å¦æ˜¯å…³é”®è¯ä¿¡æ¯å¼€å§‹
                if (line.includes('å…³é”®è¯ä¿¡æ¯') || line.toLowerCase().includes('keyword')) {
                    currentSection = 'keyword';
                    console.log('Switched to keyword section');
                    continue;
                }

                // æ£€æŸ¥æ˜¯å¦æ˜¯SERPé“¾æ¥å¼€å§‹
                if (line.includes('SERP links') || (line.includes('URL') && line.includes('ç½‘ç«™æ ‡é¢˜')) ||
                    (currentSection !== 'keyword' && !line.includes('\t') && !keywordHeaderFound &&
                     (lines[i+1] && !lines[i+1].trim()) &&
                     (lines[i+2] && (lines[i+2].includes('â€º') || lines[i+2].includes('http'))))) {
                    currentSection = 'serp';
                    serpLinksStarted = true;
                    console.log('Switched to SERP section');

                    // å¦‚æœè¿™è¡Œå°±æ˜¯ç¬¬ä¸€ä¸ªGoogleæ ¼å¼æ¡ç›®çš„æ ‡é¢˜ï¼Œä¸è¦è·³è¿‡
                    if (!line.includes('SERP links') && !line.includes('URL')) {
                        i--; // å›é€€ä¸€è¡Œï¼Œå› ä¸ºå½“å‰è¡Œå¯èƒ½æ˜¯ç¬¬ä¸€ä¸ªæ¡ç›®çš„æ ‡é¢˜
                    }
                    continue;
                }

                // è§£æå…³é”®è¯æ•°æ®
                if (currentSection === 'keyword' && line.includes('\t') && !keywordHeaderFound) {
                    const parts = line.split('\t');
                    console.log('Keyword line parts:', parts);
                    console.log('Parts count:', parts.length);

                    // è·³è¿‡è¡¨å¤´è¡Œ
                    if (line.toLowerCase().includes('keyword') && line.toLowerCase().includes('difficulty')) {
                        console.log('Skipping header line');
                        continue;
                    }

                    // è§£ææ•°æ®è¡Œ
                    if (parts.length >= 13) {
                        // æŒ‰ç…§å®é™…æ ¼å¼è§£æï¼š
                        // 0:Keyword, 1:Position, 2:Previous position, 3:Search Volume, 4:Keyword Difficulty, 5:CPC, 6:URL, 7:Traffic, 8:Traffic (%), 9:Traffic Cost, 10:Competition, 11:Number of Results, 12:intitle
                        result.keywordInfo = {
                            keyword: parts[0] || '',
                            position: parts[1] || '',
                            difficulty: parts[4] || '',
                            results: parts[11] || '', // Number of Results
                            intitle: parts[12] || '', // intitle ç»“æœæ•°
                            url: parts[6] || '',
                            traffic: parts[7] || ''
                        };
                        keywordHeaderFound = true;
                        console.log('Successfully parsed keyword info:', result.keywordInfo);
                    } else {
                        console.log('Not enough parts for keyword parsing:', parts.length);
                    }
                }

                // è§£æSERPé“¾æ¥
                if (currentSection === 'serp' && serpLinksStarted) {
                    // å¦‚æœæ˜¯ç©ºè¡Œï¼Œè·³è¿‡
                    if (!line) {
                        continue;
                    }

                    // æ£€æŸ¥æ¥ä¸‹æ¥å‡ è¡Œæ˜¯å¦ç¬¦åˆGoogleæ ¼å¼
                    let isGoogleFormat = false;
                    for (let j = i + 1; j <= i + 4 && j < lines.length; j++) {
                        const nextLine = lines[j].trim();
                        if (nextLine.includes('â€º')) {
                            isGoogleFormat = true;
                            break;
                        }
                    }

                    if (isGoogleFormat) {
                        // Googleæ ¼å¼ï¼šè§£æä»å½“å‰ä½ç½®å¼€å§‹çš„æ‰€æœ‰æ•°æ®
                        const googleResults = parseGoogleFormat(lines, i);
                        if (googleResults.length > 0) {
                            result.serpLinks.push(...googleResults);
                            console.log('Parsed Google format results:', googleResults);
                            // è¯¦ç»†æ‰“å°æ¯ä¸ªç»“æœä»¥è°ƒè¯•
                            googleResults.forEach((item, index) => {
                                console.log(`SERP ${index + 1}:`, item);
                            });
                        }
                        break; // å·²è§£æå®Œæ‰€æœ‰Googleæ ¼å¼æ•°æ®
                    } else if (line.includes('http')) {
                        // åŸæœ‰æ ¼å¼
                        const parsed = parseSerpLine(line);
                        if (parsed) {
                            result.serpLinks.push(parsed);
                        }
                    }
                }
            }

            console.log('Final parsing result:', result);
            return result;
        }

        function parseGoogleFormat(lines, startIndex) {
            // Googleæœç´¢ç»“æœæ ¼å¼è§£æ
            // æ ¼å¼ï¼šç¬¬1è¡Œ-æ ‡é¢˜ï¼Œç¬¬2è¡Œ-ç½‘ç«™åï¼Œç¬¬3è¡Œ-URLï¼Œç¬¬4è¡Œ-æè¿°
            console.log('parseGoogleFormat called with startIndex:', startIndex);
            console.log('Available lines from startIndex:', lines.slice(startIndex, startIndex + 25));

            const results = [];
            let i = startIndex;

            while (i < lines.length - 2) {  // è‡³å°‘éœ€è¦3è¡Œæ‰èƒ½å½¢æˆä¸€ä¸ªæ¡ç›®
                const line1 = lines[i] ? lines[i].trim() : '';
                const line2 = lines[i + 1] ? lines[i + 1].trim() : '';
                const line3 = lines[i + 2] ? lines[i + 2].trim() : '';
                const line4 = lines[i + 3] ? lines[i + 3].trim() : '';

                console.log(`Checking entry starting at line ${i}:`);
                console.log(`  Line ${i}: "${line1}" (potential title)`);
                console.log(`  Line ${i + 1}: "${line2}" (potential website)`);
                console.log(`  Line ${i + 2}: "${line3}" (potential URL)`);
                console.log(`  Line ${i + 3}: "${line4}" (potential description)`);

                // æ£€æŸ¥æ˜¯å¦ç¬¦åˆGoogleæ ¼å¼ï¼šç¬¬3è¡ŒåŒ…å«â€ºç¬¦å·
                if (line3.includes('â€º')) {
                    let title = line1;
                    let url = line3.replace(/\s*â€º\s*/g, '/');
                    url = url.replace(/\s+/g, '');

                    if (!url.startsWith('http')) {
                        url = 'https://' + url;
                    }

                    if (title && url) {
                        results.push({
                            title: title,
                            url: url
                        });
                        console.log(`  âœ“ Added result: title="${title}", url="${url}"`);

                        // è·³è¿‡è¿™ä¸ªå®Œæ•´çš„æ¡ç›®ï¼ˆ4è¡Œï¼‰
                        i += 4;

                        // è·³è¿‡å¯èƒ½çš„ç©ºè¡Œ
                        while (i < lines.length && !lines[i].trim()) {
                            i++;
                        }
                    } else {
                        i++;
                    }
                } else {
                    // ä¸ç¬¦åˆæ ¼å¼ï¼Œç»§ç»­ä¸‹ä¸€è¡Œ
                    i++;
                }
            }

            console.log('parseGoogleFormat final results:', results);
            return results;
        }

        function parseSerpLine(line) {
            // ç¤ºä¾‹æ ¼å¼ï¼šhttps://funy.ai/ai-video/clipfly-ai-kissing-generator-free/#:~:text=Merge%20t...1ClipFly AI Kissing Generator: Create Free Kiss Videos - Funy AIFuny AIhttps:...
            // æˆ–ï¼šhttps://funy.ai/ai-kissing-video-free/2AI Kissing Video Generator Online - Free & No Sign UpFuny AIhttps://funy.ai ...

            // æå–å¼€å¤´çš„URL
            const urlMatch = line.match(/^(https?:\/\/[^\s#]*[^\d])/);
            if (!urlMatch) return null;

            const url = urlMatch[1];
            let remainingText = line.replace(urlMatch[0], '').trim();

            // ç§»é™¤å¼€å¤´å¯èƒ½çš„åºå·
            remainingText = remainingText.replace(/^\d+/, '').trim();

            // æŸ¥æ‰¾æ ‡é¢˜ï¼šä»åºå·ååˆ°"https"ä¹‹å‰çš„å†…å®¹
            let title = '';
            const httpsIndex = remainingText.indexOf('https');
            if (httpsIndex > 0) {
                title = remainingText.substring(0, httpsIndex).trim();
            } else {
                title = remainingText;
            }

            // æ¸…ç†æ ‡é¢˜ï¼Œç§»é™¤å¤šä½™çš„ç½‘ç«™åç§°é‡å¤
            title = title.replace(/([A-Za-z\s]+)\1+$/, '$1'); // ç§»é™¤é‡å¤çš„ç½‘ç«™å
            title = title.replace(/\s+/g, ' ').trim(); // è§„èŒƒåŒ–ç©ºæ ¼

            if (!title) return null;

            return {
                url: url,
                title: title
            };
        }

        function handleFileSelect(input) {
            if (input.files && input.files[0]) {
                const file = input.files[0];
                updateFileStatus(file.name);
            }
        }

        function displayKeywordMetrics(keywordInfo, targetDiv) {
            const kw = keywordInfo;
            const results = parseFloat(kw.results) || 0;
            const intitle = parseFloat(kw.intitle) || 0;
            const difficulty = parseFloat(kw.difficulty) || 0;
            const traffic = parseFloat(kw.traffic) || 0;

            // è®¡ç®— KGR (Keyword Golden Ratio) = intitle / Number of Results
            let kgr = 0;
            let kgrStatus = '';
            if (results > 0) {
                kgr = (intitle / results).toFixed(4);
                if (kgr <= 0.25) kgrStatus = 'ğŸŸ¢ ä¼˜ç§€';
                else if (kgr <= 0.5) kgrStatus = 'ğŸŸ¡ è‰¯å¥½';
                else if (kgr <= 1) kgrStatus = 'ğŸŸ  ä¸€èˆ¬';
                else kgrStatus = 'ğŸ”´ è¾ƒå·®';
            } else {
                kgr = 'N/A';
                kgrStatus = 'æ— æ³•è®¡ç®—';
            }

            targetDiv.innerHTML = `
                <h3 style="color: #644a40; margin-bottom: 8px; font-size: 1em;">å…³é”®è¯æŒ‡æ ‡</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)); gap: 8px;">
                    <div style="background: #f5f5f5; padding: 8px; border-radius: 4px; text-align: center;">
                        <div style="font-size: 12px; color: #666;">æœç´¢ç»“æœæ•°é‡</div>
                        <div style="font-weight: 600; color: #644a40; font-size: 14px;">${kw.results ? parseInt(kw.results).toLocaleString() : '0'}</div>
                    </div>
                    <div style="background: #f5f5f5; padding: 8px; border-radius: 4px; text-align: center;">
                        <div style="font-size: 12px; color: #666;">Intitle</div>
                        <div style="font-weight: 600; color: #644a40; font-size: 14px;">${kw.intitle ? parseInt(kw.intitle).toLocaleString() : '0'}</div>
                    </div>
                    <div style="background: #f5f5f5; padding: 8px; border-radius: 4px; text-align: center;">
                        <div style="font-size: 12px; color: #666;">KDéš¾åº¦</div>
                        <div style="font-weight: 600; color: #644a40; font-size: 14px;">${kw.difficulty}</div>
                    </div>
                    <div style="background: #f5f5f5; padding: 8px; border-radius: 4px; text-align: center;">
                        <div style="font-size: 12px; color: #666;">KGR</div>
                        <div style="font-weight: 600; color: #644a40; font-size: 14px;">${kgr}</div>
                    </div>
                </div>
            `;
        }

        function displaySupplementInfo(data) {
            const supplementDiv = document.getElementById('supplementInfo');
            let html = '';

            // ä¿å­˜SERPé“¾æ¥æ•°æ®åˆ°å…¨å±€å˜é‡
            globalSerpLinks = data.serpLinks || [];


            // SERPé“¾æ¥è¡¨æ ¼ï¼ˆæ— æ ‡é¢˜ï¼‰
            if (data.serpLinks.length > 0) {
                html += `
                    <div style="overflow-x: auto;">
                        <table style="width: 100%; border-collapse: collapse; background: #fcfcfc; border: 1px solid #d8d8d8; border-radius: 6px;">
                            <thead>
                                <tr style="background: #efefef;">
                                    <th style="padding: 8px; text-align: left; border-bottom: 1px solid #d8d8d8; color: #644a40; font-weight: 600; font-size: 14px;">#</th>
                                    <th style="padding: 8px; text-align: left; border-bottom: 1px solid #d8d8d8; color: #644a40; font-weight: 600; font-size: 14px;">æ ‡é¢˜</th>
                                    <th style="padding: 8px; text-align: left; border-bottom: 1px solid #d8d8d8; color: #644a40; font-weight: 600; font-size: 14px;">ç½‘å€</th>
                                </tr>
                            </thead>
                            <tbody>
                `;

                data.serpLinks.forEach((link, index) => {
                    html += `
                        <tr style="border-bottom: 1px solid #e8e8e8;">
                            <td style="padding: 8px; font-weight: 600; color: #644a40; font-size: 14px; line-height: 1.3;">${index + 1}</td>
                            <td style="padding: 8px; color: #202020; line-height: 1.3; font-size: 14px;">${link.title}</td>
                            <td style="padding: 8px; font-size: 14px; line-height: 1.3;"><a href="${link.url}" target="_blank" style="color: #644a40; text-decoration: underline; word-break: break-all;">${link.url}</a></td>
                        </tr>
                    `;
                });

                html += `
                            </tbody>
                        </table>
                    </div>
                `;
            }

            supplementDiv.innerHTML = html;
        }

        function testParseData() {
            const data = document.getElementById('supplementDataInput').value.trim();
            if (!data) {
                alert('è¯·å…ˆè¾“å…¥è¡¥å……æ•°æ®');
                return;
            }

            console.log('=== å¼€å§‹æµ‹è¯•è§£æ ===');
            try {
                const result = parseKeywordAndSerpData(data);
                console.log('=== è§£æç»“æœ ===', result);
                alert(`è§£æç»“æœï¼š\nå…³é”®è¯: ${result.keywordInfo?.keyword || 'æœªæ‰¾åˆ°'}\nç»“æœæ•°: ${result.keywordInfo?.results || 'æœªæ‰¾åˆ°'}\nSERPé“¾æ¥: ${result.serpLinks?.length || 0}ä¸ª\n\nè¯·æŸ¥çœ‹æ§åˆ¶å°è·å–è¯¦ç»†ä¿¡æ¯`);
            } catch (error) {
                console.error('è§£æå¤±è´¥:', error);
                alert('è§£æå¤±è´¥ï¼Œè¯·æŸ¥çœ‹æ§åˆ¶å°è·å–è¯¦ç»†ä¿¡æ¯');
            }
        }

        // å…¨å±€å˜é‡å­˜å‚¨SERPé“¾æ¥æ•°æ®
        let globalSerpLinks = [];

        // CORSä»£ç†æœåŠ¡åˆ—è¡¨
        const proxyUrls = [
            'https://api.allorigins.win/get?url=',
            'https://corsproxy.io/?',
            'https://api.codetabs.com/v1/proxy?quest=',
            'https://thingproxy.freeboard.io/fetch/'
        ];

        async function fetchPageContent(url, timeout = 12000) {
            const encodedUrl = encodeURIComponent(url);

            for (let i = 0; i < proxyUrls.length; i++) {
                try {
                    console.log(`å°è¯•ä½¿ç”¨ä»£ç† ${i + 1}: ${proxyUrls[i]}`);

                    // åˆ›å»ºå¸¦è¶…æ—¶çš„fetchè¯·æ±‚
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), timeout);

                    let proxyUrl, response;

                    if (proxyUrls[i].includes('allorigins')) {
                        proxyUrl = `${proxyUrls[i]}${encodedUrl}`;
                        response = await fetch(proxyUrl, { signal: controller.signal });
                        clearTimeout(timeoutId);

                        if (response.ok) {
                            const data = await response.json();
                            return {
                                text: () => Promise.resolve(data.contents),
                                ok: true,
                                status: 200
                            };
                        }
                    } else if (proxyUrls[i].includes('codetabs')) {
                        proxyUrl = `${proxyUrls[i]}${encodedUrl}`;
                        response = await fetch(proxyUrl, { signal: controller.signal });
                        clearTimeout(timeoutId);

                        if (response.ok) {
                            return response;
                        }
                    } else if (proxyUrls[i].includes('thingproxy')) {
                        proxyUrl = `${proxyUrls[i]}${url}`;  // thingproxyä¸éœ€è¦ç¼–ç 
                        response = await fetch(proxyUrl, { signal: controller.signal });
                        clearTimeout(timeoutId);

                        if (response.ok) {
                            return response;
                        }
                    } else {
                        // corsproxy å’Œå…¶ä»–ä»£ç†
                        proxyUrl = `${proxyUrls[i]}${encodedUrl}`;
                        response = await fetch(proxyUrl, { signal: controller.signal });
                        clearTimeout(timeoutId);

                        if (response.ok) {
                            return response;
                        }
                    }
                } catch (error) {
                    console.warn(`ä»£ç† ${i + 1} å¤±è´¥:`, error.name === 'AbortError' ? 'è¶…æ—¶' : error.message);
                    if (i === proxyUrls.length - 1) {
                        throw new Error(`æ‰€æœ‰ä»£ç†éƒ½å¤±è´¥äº†ã€‚æœ€åä¸€ä¸ªé”™è¯¯: ${error.message}`);
                    }
                }
            }
        }

        async function batchDownloadSerpUrls() {
            if (!globalSerpLinks || globalSerpLinks.length === 0) {
                showError('æ²¡æœ‰å¯ä¸‹è½½çš„SERPé“¾æ¥');
                return;
            }

            const progressDiv = document.getElementById('batchProgress');
            progressDiv.style.display = 'block';

            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            const progressCount = document.getElementById('progressCount');
            const progressDetails = document.getElementById('progressDetails');

            let completed = 0;
            let successful = 0;
            const urls = globalSerpLinks.map(link => link.url);

            progressCount.textContent = `0/${urls.length}`;
            progressDetails.innerHTML = '';

            try {
                progressText.textContent = `å¼€å§‹å¹¶å‘ä¸‹è½½ ${urls.length} ä¸ªé“¾æ¥...`;

                // åˆ›å»ºæ‰€æœ‰ä¸‹è½½ä»»åŠ¡
                const downloadTasks = urls.map(async (url, i) => {
                    try {
                        const response = await fetchPageContent(url, 12000); // 12ç§’è¶…æ—¶
                        const html = await response.text();

                        const urlObj = new URL(url);
                        const filename = `${urlObj.hostname}.html`;

                        downloadHTML(html, filename);
                        return { url, status: 'success', filename };
                    } catch (error) {
                        console.error(`ä¸‹è½½å¤±è´¥ ${url}:`, error);
                        return { url, status: 'failed', error: error.message };
                    }
                });

                // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆï¼Œå¹¶å®æ—¶æ›´æ–°è¿›åº¦
                const results = [];
                for (const task of downloadTasks) {
                    const result = await task;
                    results.push(result);
                    completed++;

                    if (result.status === 'success') {
                        successful++;
                        progressDetails.innerHTML += `<div style="color: #644a40;">âœ“ ${result.url}</div>`;
                    } else {
                        progressDetails.innerHTML += `<div style="color: #e54d2e;">âœ— ${result.url} (${result.error})</div>`;
                    }

                    progressCount.textContent = `${completed}/${urls.length}`;
                    progressFill.style.width = `${(completed / urls.length) * 100}%`;
                    progressText.textContent = `å·²å®Œæˆ: ${completed}/${urls.length}`;
                }

                progressText.textContent = `SERPé“¾æ¥ä¸‹è½½å®Œæˆï¼æˆåŠŸ: ${successful}ä¸ª`;

            } catch (error) {
                showError('SERPé“¾æ¥æ‰¹é‡ä¸‹è½½å¤±è´¥: ' + error.message);
            }
        }

        function copyAllUrls() {
            if (globalSerpLinks.length === 0) {
                return;
            }

            const urls = globalSerpLinks.map(link => link.url).join('\n');

            // ä½¿ç”¨Clipboard APIå¤åˆ¶åˆ°å‰ªè´´æ¿
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(urls).catch(err => {
                    console.error('å¤åˆ¶å¤±è´¥:', err);
                    fallbackCopyTextToClipboard(urls);
                });
            } else {
                // å¤‡ç”¨æ–¹æ¡ˆ
                fallbackCopyTextToClipboard(urls);
            }
        }

        function fallbackCopyTextToClipboard(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.top = '0';
            textArea.style.left = '0';
            textArea.style.position = 'fixed';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();

            try {
                document.execCommand('copy');
            } catch (err) {
                console.error('å¤åˆ¶å¤±è´¥:', err);
            }

            document.body.removeChild(textArea);
        }

    </script>
</body>
</html>